import random # Import random for potential volatile status checks (e.g., confusion hit chance)
import math # Import math for confusion damage calculation
from typing import List, Dict, Any, Optional, Tuple, Callable
from backend.models.pokemon import Pokemon
from backend.models.status_effect import StatusEffect
from backend.core.battle.events import (
    BattleEvent, StatusEffectAppliedEvent, StatStageChangeEvent, BattleMessageEvent,
    StatusEffectRemovedEvent, DamageDealtEvent, ConfusionDamageEvent, # Import necessary events
    VolatileStatusChangeEvent, FlinchEvent # Import FlinchEvent
)
from backend.data_access.metadata_loader import MetadataRepository
from backend.utils.logger import get_logger
from backend.core.battle.formulas import calculate_damage, calculate_confusion_damage # Import the damage calculation function and calculate_confusion_damage

logger = get_logger(__name__)

class StatusEffectHandler:
    """
    Handles the application and management of status effects and stat stage changes
    during a battle.
    """
    def __init__(self, metadata_repo: MetadataRepository):
        """
        Initializes the StatusEffectHandler with necessary dependencies.

        Args:
            metadata_repo: The repository for accessing game metadata.
        """
        self._metadata_repo = metadata_repo
        # 易变状态处理器映射表
        self._volatile_status_handlers = {
            "confusion": self._handle_confusion,
            "flinch": self._handle_flinch,
            "infatuation": self._handle_infatuation,
            "taunt": self._handle_taunt,
            "encore": self._handle_encore,
            "trap": self._handle_trap,
            # 可根据需要添加更多处理器
        }

    def apply_status_effect(self, pokemon: Pokemon, status_effect: StatusEffect) -> List[BattleEvent]:
        """
        Attempts to apply a major status effect to a Pokemon, checking for immunities.

        Args:
            pokemon: The Pokemon to apply the status effect to.
            status_effect: The StatusEffect object to apply.

        Returns:
            A list of BattleEvent objects generated by the application attempt.
        """
        events: List[BattleEvent] = []

        # Check if the Pokemon already has a major status effect
        if pokemon.major_status_effect:
            message = f"{pokemon.nickname} 已经处于 {pokemon.major_status_effect.name} 状态了！" # TODO: Refine message (S133 refinement)
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"Pokemon {pokemon.nickname} already has a major status effect: {pokemon.major_status_effect.name}")
            return events

        # Check for immunity based on item (S132 refinement - Item first)
        if self._metadata_repo.is_immune_by_item(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname} 的 {pokemon.held_item.name} 使其不会{status_effect.name}！" if pokemon.held_item else f"{pokemon.nickname} 不会{status_effect.name}！" # TODO: Refine message (S133 refinement)
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to held item.")
             return events

        # Check for immunity based on ability (S132 refinement - Ability second)
        if self._metadata_repo.is_immune_by_ability(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname} 的 {pokemon.ability.name} 使其不会{status_effect.name}！" if pokemon.ability else f"{pokemon.nickname} 不会{status_effect.name}！" # TODO: Refine message (S133 refinement)
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to ability.")
             return events

        # Check for immunity based on type (S132 refinement - Type last)
        if self._metadata_repo.is_immune_by_type(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname} 的属性使其不会{status_effect.name}！" # TODO: Refine message (S133 refinement)
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to type.")
             return events

        # If not immune and no existing major status, apply the status effect
        pokemon.major_status_effect = status_effect
        message = f"{pokemon.nickname} {status_effect.name}了！" # TODO: Refine status message (S133 refinement)
        events.append(StatusEffectAppliedEvent(pokemon=pokemon, status_effect=status_effect, message=message))
        logger.info(f"Applied status effect {status_effect.name} to {pokemon.nickname}")

        # TODO: Add logic for specific status effect application side effects (e.g., Burn halves Attack) (S131 refinement)
        # This might involve applying stat stage changes or other effects immediately upon application.

        return events

    def remove_status_effect(self, pokemon: Pokemon, status_effect_logic_key: str) -> List[BattleEvent]:
        """
        Attempts to remove a major status effect from a Pokemon.

        Args:
            pokemon: The Pokemon to remove the status effect from.
            status_effect_logic_key: The logic key of the status effect to remove.

        Returns:
            A list of BattleEvent objects generated by the removal attempt.
        """
        events: List[BattleEvent] = []
        if pokemon.major_status_effect and pokemon.major_status_effect.logic_key == status_effect_logic_key:
            removed_status_name = pokemon.major_status_effect.name
            pokemon.major_status_effect = None
            message = f"{pokemon.nickname} 的 {removed_status_name} 恢复了！" # TODO: Refine message (S133 refinement)
            events.append(StatusEffectRemovedEvent(pokemon=pokemon, status_effect_logic_key=status_effect_logic_key, message=message))
            logger.info(f"Removed status effect {status_effect_logic_key} from {pokemon.nickname}")
        else:
            # Status effect not present or different
            message = f"{pokemon.nickname} 没有 {status_effect_logic_key} 状态。" # TODO: Refine message (S133 refinement)
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"Attempted to remove {status_effect_logic_key} from {pokemon.nickname}, but it was not present.")

        return events

    def apply_volatile_status(self, pokemon: Pokemon, volatile_status_logic_key: str, 
                             source: Optional[Pokemon] = None, turns: int = 3) -> List[BattleEvent]:
        """
        Applies a volatile status effect to a Pokemon, checking for immunities.

        Args:
            pokemon: The Pokemon to apply the volatile status effect to.
            volatile_status_logic_key: The logic key of the volatile status effect to apply.
            source: The source Pokemon that might be applying the status effect (optional).
            turns: The number of turns the status effect should last (default is 3).

        Returns:
            A list of BattleEvent objects generated by the application attempt.
        """
        events: List[BattleEvent] = []
        
        # Check if the Pokemon is already affected by this volatile status
        if volatile_status_logic_key in pokemon.volatile_status:
            logger.debug(f"{pokemon.nickname} is already affected by {volatile_status_logic_key}.")
            # Optionally add a message event here if needed
            return events

        # Check for immunity
        if self._metadata_repo.is_immune_by_item(pokemon, volatile_status_logic_key):
            item_name = pokemon.held_item.name if pokemon.held_item else "未知道具"
            message = f"{pokemon.nickname} 的 {item_name} 使其免疫了 {volatile_status_logic_key} 状态！"
            events.append(BattleMessageEvent(message=message))
            logger.info(f"{pokemon.nickname} is immune to {volatile_status_logic_key} due to held item {item_name}")
            return events
            
        if self._metadata_repo.is_immune_by_ability(pokemon, volatile_status_logic_key):
            ability_name = pokemon.ability.name if pokemon.ability else "未知特性"
            message = f"{pokemon.nickname} 的 {ability_name} 使其免疫了 {volatile_status_logic_key} 状态！"
            events.append(BattleMessageEvent(message=message))
            logger.info(f"{pokemon.nickname} is immune to {volatile_status_logic_key} due to ability {ability_name}")
            return events

        # If not immune and not already affected, apply the volatile status
        pokemon.volatile_status.append(volatile_status_logic_key)
        message = f"{pokemon.nickname} 陷入了 {volatile_status_logic_key} 状态！" # TODO: Refine message (S133 refinement)
        events.append(VolatileStatusChangeEvent(pokemon=pokemon, volatile_status_logic_key=volatile_status_logic_key, is_applied=True, message=message))
        logger.info(f"Applied volatile status {volatile_status_logic_key} to {pokemon.nickname} for {turns} turns")

        # TODO: Add logic for volatile status application side effects (e.g., confusion message on application) (S130 refinement)

        return events

    def remove_volatile_status(self, pokemon: Pokemon, volatile_status_logic_key: str) -> List[BattleEvent]:
        """
        Attempts to remove a volatile status effect from a Pokemon.

        Args:
            pokemon: The Pokemon to remove the volatile status effect from.
            volatile_status_logic_key: The logic key of the volatile status effect to remove.

        Returns:
            A list of BattleEvent objects generated by the removal attempt.
        """
        events: List[BattleEvent] = []
        if volatile_status_logic_key in pokemon.volatile_status:
            pokemon.volatile_status.remove(volatile_status_logic_key)
            message = f"{pokemon.nickname} 的 {volatile_status_logic_key} 状态消失了！" # TODO: Refine message (S133 refinement)
            events.append(VolatileStatusChangeEvent(pokemon=pokemon, volatile_status_logic_key=volatile_status_logic_key, is_applied=False, message=message))
            logger.info(f"Removed volatile status {volatile_status_logic_key} from {pokemon.nickname}")
        else:
            logger.debug(f"Attempted to remove volatile status {volatile_status_logic_key} from {pokemon.nickname}, but it was not present.")
            # Optionally add a message event here if needed

        return events

    def apply_stat_stage_change(self, pokemon: Pokemon, stat_type: str, stages: int) -> List[BattleEvent]:
        """
        Applies a stat stage change to a Pokemon.

        Args:
            pokemon: The Pokemon whose stat stage is changing.
            stat_type: The type of stat changing (e.g., 'attack', 'defense').
            stages: The number of stages to change (positive for increase, negative for decrease).

        Returns:
            A list of BattleEvent objects generated by the change attempt.
        """
        events: List[BattleEvent] = []
        current_stage = pokemon.stat_stages.get(stat_type, 0)
        new_stage = max(-6, min(6, current_stage + stages)) # Stat stages are between -6 and +6

        if new_stage == current_stage:
            # No change occurred (e.g., already at +6 and tried to increase)
            message = f"{pokemon.nickname} 的 {stat_type} 没有变化！" # TODO: Refine message based on attempt vs actual change
            events.append(BattleMessageEvent(message=message))
            return events

        pokemon.stat_stages[stat_type] = new_stage

        message = f"{pokemon.nickname} 的 {stat_type} {'提高' if stages > 0 else '降低'}了！" # Basic message
        # TODO: Refine message based on number of stages (e.g., sharply rose/fell) (S119 refinement)

        events.append(StatStageChangeEvent(pokemon=pokemon, stat_type=stat_type, stages_changed=stages, new_stage=new_stage, message=message))

        return events

    def process_start_of_turn_volatile_effects(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        Processes volatile status effects that trigger at the start of a Pokemon's turn.

        Args:
            pokemon: The Pokemon whose volatile statuses are being processed.

        Returns:
            A list of BattleEvent objects generated by the volatile status effects.
        """
        events: List[BattleEvent] = []
        
        # 遍历所有易变状态，并使用对应的处理器处理
        for status in pokemon.volatile_statuses[:]:  # 创建副本以允许在迭代时修改
            handler = self._volatile_status_handlers.get(status.logic_key)
            if handler:
                status_events = handler(pokemon, status)
                events.extend(status_events)
        
        return events

    def process_end_of_turn_volatile_effects(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        Processes volatile status effects that trigger at the end of a Pokemon's turn.

        Args:
            pokemon: The Pokemon whose volatile statuses are being processed.

        Returns:
            A list of BattleEvent objects generated by the volatile status effects.
        """
        events: List[BattleEvent] = []
        
        # 遍历所有易变状态，减少持续回合并检查是否到期
        for status in pokemon.volatile_statuses[:]:  # 创建副本以允许在迭代时删除
            if status.remaining_turns > 0:
                status.remaining_turns -= 1
                
            if status.remaining_turns <= 0:
                # 状态到期，移除它
                pokemon.volatile_statuses.remove(status)
                
                # 添加状态移除消息和事件
                status_message = self._get_status_removal_message(status.logic_key, pokemon)
                events.append(BattleMessageEvent(message=status_message))
                
                events.append(VolatileStatusChangeEvent(
                    pokemon=pokemon,
                    status_logic_key=status.logic_key,
                    is_applied=False,
                    message=status_message
                ))
                
                logger.info(f"{status.logic_key} status expired for {pokemon.nickname}")
                
        return events

    # ===== 各种易变状态的处理器 =====
    
    def _handle_confusion(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理混乱状态"""
        events: List[BattleEvent] = []
        
        # 混乱状态的效果处理
        # 1/3 的几率混乱命中自己
        if random.random() < 1/3:  # 33% 几率混乱导致自伤
            # 计算混乱伤害
            confusion_damage = calculate_confusion_damage(pokemon)
            
            # 应用混乱伤害
            pokemon.current_hp = max(0, pokemon.current_hp - confusion_damage)
            
            # 创建混乱伤害事件
            events.append(ConfusionDamageEvent(
                pokemon=pokemon,
                damage=confusion_damage,
                message=f"{pokemon.nickname} 混乱了！它攻击了自己，造成了 {confusion_damage} 点伤害！"
            ))
            
            logger.info(f"{pokemon.nickname} hit itself in confusion for {confusion_damage} damage")
        else:
            # 混乱但本回合没有自伤
            events.append(BattleMessageEvent(
                message=f"{pokemon.nickname} 混乱了，但它仍然能够行动！"
            ))
            
            logger.info(f"{pokemon.nickname} is confused but did not hit itself this turn")
            
        return events
        
    def _handle_flinch(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理畏缩状态"""
        events: List[BattleEvent] = []
        
        # 畏缩导致无法行动
        message = f"{pokemon.nickname}因畏缩而无法行动！"
        events.append(BattleMessageEvent(message=message))
        events.append(FlinchEvent(pokemon=pokemon))
        
        # 畏缩只持续一回合，使用后立即移除
        pokemon.volatile_statuses.remove(status)
        
        return events
        
    def _handle_infatuation(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理迷恋状态"""
        events: List[BattleEvent] = []
        
        # 迷恋状态在check_can_act中检查是否导致无法行动
        # 这里可以添加一些视觉或提示效果
        message = f"{pokemon.nickname}被迷住了！"
        events.append(BattleMessageEvent(message=message))
        
        return events
        
    def _handle_taunt(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理挑衅状态"""
        events: List[BattleEvent] = []
        
        # 挑衅状态的效果（禁止使用非攻击性技能）会在技能选择阶段检查
        message = f"{pokemon.nickname}被挑衅了，只能使用攻击性技能！"
        events.append(BattleMessageEvent(message=message))
        
        return events
        
    def _handle_encore(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理鼓掌状态"""
        events: List[BattleEvent] = []
        
        # 鼓掌效果（强制使用最后一次使用的技能）会在技能选择阶段处理
        last_skill = status.custom_data.get("last_skill")
        if last_skill:
            message = f"{pokemon.nickname}受到鼓掌效果，必须使用{last_skill}！"
        else:
            message = f"{pokemon.nickname}受到鼓掌效果！"
        events.append(BattleMessageEvent(message=message))
        
        return events
    
    def _handle_trap(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理束缚状态"""
        events: List[BattleEvent] = []
        
        # 计算束缚伤害
        max_hp = pokemon.get_stat("hp")
        trap_damage = max(1, max_hp // 16)  # 至少1点伤害
        
        # 应用伤害
        old_hp = pokemon.current_hp
        pokemon.current_hp = max(0, pokemon.current_hp - trap_damage)
        
        # 获取束缚来源（如果有）
        source = status.custom_data.get("source", "")
        trap_type = status.custom_data.get("trap_type", "束缚")
        
        message = f"{pokemon.nickname}受到了{trap_type}的伤害！"
        events.append(BattleMessageEvent(message=message))
        
        events.append(DamageDealtEvent(
            pokemon=pokemon,
            damage=trap_damage,
            old_hp=old_hp,
            new_hp=pokemon.current_hp,
            damage_source="trap"
        ))
        
        return events
    
    # ===== 辅助方法 =====
    
    def _get_status_application_message(self, status_logic_key: str, pokemon: Pokemon) -> str:
        """获取状态施加时的消息"""
        status_messages = {
            "confusion": f"{pokemon.nickname} 混乱了！",
            "flinch": f"{pokemon.nickname} 畏缩了！",
            "infatuation": f"{pokemon.nickname}被迷住了！",
            "taunt": f"{pokemon.nickname} 被挑衅了！",
            "encore": f"{pokemon.nickname} 被鼓掌了！",
            # 可根据需要添加更多状态消息
        }
        
        return status_messages.get(status_logic_key, f"{pokemon.nickname} 受到了 {status_logic_key} 状态的影响！")
        
    def _get_status_removal_message(self, status_logic_key: str, pokemon: Pokemon) -> str:
        """获取状态移除时的消息"""
        status_messages = {
            "confusion": f"{pokemon.nickname} 不再混乱了！",
            "flinch": f"{pokemon.nickname} 不再畏缩了！",
            "infatuation": f"{pokemon.nickname}不再被迷住了！",
            "taunt": f"{pokemon.nickname} 不再被挑衅了！",
            "encore": f"{pokemon.nickname} 不再被鼓掌约束了！",
            # 可根据需要添加更多状态消息
        }
        
        return status_messages.get(status_logic_key, f"{pokemon.nickname} 不再受到 {status_logic_key} 状态的影响！")

    def check_can_act(self, pokemon: Pokemon) -> Tuple[bool, Optional[BattleEvent]]:
        """
        检查宝可梦是否可以在本回合采取行动。
        某些状态效果（如睡眠、冰冻）会阻止宝可梦行动。
        
        Args:
            pokemon: 要检查的宝可梦
            
        Returns:
            元组(can_act, event)，can_act为True表示可以行动，False表示不能行动
            如果不能行动，event包含相应的战斗事件（如消息事件）
        """
        # 检查主要状态效果
        if pokemon.major_status:
            # 冰冻状态：通常无法行动，但有10%的几率解冻
            if pokemon.major_status.effect_logic_key == "frozen":
                # 10%的几率自然解冻
                if random.random() < 0.1:
                    # 解除冰冻状态
                    status = pokemon.major_status
                    pokemon.major_status = None
                    message = f"{pokemon.nickname}解冻了！"
                    event = StatusEffectRemovedEvent(
                        pokemon=pokemon,
                        status_logic_key=status.effect_logic_key,
                        message=message
                    )
                    return True, event
                else:
                    # 仍然冰冻，无法行动
                    message = f"{pokemon.nickname}被冰冻住了，无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
                
            # 睡眠状态：无法行动，但可能在回合结束时醒来
            elif pokemon.major_status.effect_logic_key == "sleep":
                # 处理睡眠回合减少逻辑在process_end_of_turn_major_status中
                message = f"{pokemon.nickname}正在睡觉，无法行动！"
                event = BattleMessageEvent(message=message)
                return False, event
            
            # 麻痹状态：25%几率无法行动
            elif pokemon.major_status.effect_logic_key == "paralysis":
                if random.random() < 0.25:  # 25%几率无法行动
                    message = f"{pokemon.nickname}因麻痹无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
        
        # 检查易变状态中的限制
        for status in pokemon.volatile_statuses:
            if status.effect_logic_key == "infatuation":
                # 50%几率因迷恋而无法行动
                if random.random() < 0.5:
                    message = f"{pokemon.nickname}因为迷恋无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
                
        # 没有阻止行动的状态效果
        return True, None

    def process_end_of_turn_major_status(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        处理回合结束时主要状态效果的变化（如中毒伤害、烧伤伤害、睡眠回合减少等）。
        
        Args:
            pokemon: 要处理状态效果的宝可梦
            
        Returns:
            产生的战斗事件列表
        """
        events: List[BattleEvent] = []
        
        if not pokemon.major_status:
            return events
        
        status = pokemon.major_status
        
        # 处理中毒状态（扣除最大HP的1/8）
        if status.effect_logic_key == "poison":
            # 计算中毒伤害
            max_hp = pokemon.get_stat("hp")
            poison_damage = max(1, max_hp // 8)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - poison_damage)
            
            message = f"{pokemon.nickname}受到了中毒伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=poison_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="poison"
            ))
            
        # 处理剧毒状态（扣除递增的HP）
        elif status.effect_logic_key == "toxic":
            # 获取或初始化剧毒回合计数
            turn_count = status.custom_data.get("turn_count", 1)
            
            # 计算剧毒伤害（初始1/16，每回合递增1/16）
            max_hp = pokemon.get_stat("hp")
            toxic_damage = max(1, (max_hp * turn_count) // 16)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - toxic_damage)
            
            message = f"{pokemon.nickname}受到了剧毒伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=toxic_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="toxic"
            ))
            
            # 更新剧毒回合计数
            status.custom_data["turn_count"] = turn_count + 1
            
        # 处理灼伤状态（扣除最大HP的1/8，物理攻击降低）
        elif status.effect_logic_key == "burn":
            # 计算灼伤伤害
            max_hp = pokemon.get_stat("hp")
            burn_damage = max(1, max_hp // 8)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - burn_damage)
            
            message = f"{pokemon.nickname}受到了灼伤伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=burn_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="burn"
            ))
        
        # 处理睡眠状态（回合减少，可能醒来）
        elif status.effect_logic_key == "sleep":
            # 获取或初始化剩余睡眠回合
            remaining_turns = status.remaining_turns
            
            if remaining_turns <= 0:
                # 初始化剩余回合（如果没有设置）
                remaining_turns = random.randint(1, 3)
                status.remaining_turns = remaining_turns
            
            # 减少剩余回合
            status.remaining_turns -= 1
            
            # 检查是否应该醒来
            if status.remaining_turns <= 0:
                # 移除睡眠状态
                pokemon.major_status = None
                
                message = f"{pokemon.nickname}醒来了！"
                events.append(BattleMessageEvent(message=message))
                
                events.append(StatusEffectRemovedEvent(
                    pokemon=pokemon,
                    status_logic_key="sleep",
                    message=message
                ))
        
        return events

    def apply_status_effect(self, pokemon: Pokemon, status_logic_key: str, turns: int = -1, custom_data: Dict[str, Any] = None) -> List[BattleEvent]:
        """
        为宝可梦施加状态效果。
        
        Args:
            pokemon: 施加状态效果的目标宝可梦
            status_logic_key: 状态效果的逻辑键
            turns: 状态效果持续的回合数（-1表示无限持续）
            custom_data: 与状态相关的自定义数据
            
        Returns:
            产生的战斗事件列表
        """
        events: List[BattleEvent] = []
        
        # 检查是否免疫该状态
        if self._is_immune_to_status(pokemon, status_logic_key):
            message = f"{pokemon.nickname}免疫{status_logic_key}状态！"
            events.append(BattleMessageEvent(message=message))
            return events
        
        # 区分主要状态效果和易变状态效果
        if status_logic_key in ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"]:
            # 主要状态效果（宝可梦一次只能有一个）
            
            # 如果已经有主要状态，先移除
            if pokemon.major_status:
                old_status = pokemon.major_status
                pokemon.major_status = None
                
                removal_message = self._get_status_removal_message(old_status.effect_logic_key, pokemon)
                events.append(BattleMessageEvent(message=removal_message))
                
                events.append(StatusEffectRemovedEvent(
                    pokemon=pokemon,
                    status_logic_key=old_status.effect_logic_key,
                    message=removal_message
                ))
            
            # 创建新的状态效果
            status_metadata = self._metadata_repo.get_status_effect_by_logic_key(status_logic_key)
            if not status_metadata:
                logger.error(f"未找到状态效果元数据：{status_logic_key}")
                return events
            
            status = StatusEffect(
                status_effect_id=status_metadata["id"],
                name=status_metadata["name"],
                description=status_metadata.get("description", ""),
                effect_logic_key=status_logic_key,
                remaining_turns=turns,
                custom_data=custom_data or {}
            )
            
            # 应用主要状态
            pokemon.major_status = status
            
            # 生成应用消息和事件
            application_message = self._get_status_application_message(status_logic_key, pokemon)
            events.append(BattleMessageEvent(message=application_message))
            
            events.append(StatusEffectAppliedEvent(
                pokemon=pokemon,
                status_logic_key=status_logic_key,
                message=application_message
            ))
            
        else:
            # 易变状态效果（宝可梦可以同时拥有多个）
            
            # 检查是否已经有该状态
            for existing_status in pokemon.volatile_statuses:
                if existing_status.effect_logic_key == status_logic_key:
                    # 已存在该状态，更新持续回合
                    existing_status.remaining_turns = turns
                    return events
            
            # 创建新的状态效果
            status_metadata = self._metadata_repo.get_status_effect_by_logic_key(status_logic_key)
            if not status_metadata:
                logger.error(f"未找到状态效果元数据：{status_logic_key}")
                return events
            
            status = StatusEffect(
                status_effect_id=status_metadata["id"],
                name=status_metadata.get("name", status_logic_key),
                description=status_metadata.get("description", ""),
                effect_logic_key=status_logic_key,
                remaining_turns=turns,
                custom_data=custom_data or {}
            )
            
            # 添加易变状态
            pokemon.volatile_statuses.append(status)
            
            # 生成应用消息和事件
            application_message = self._get_status_application_message(status_logic_key, pokemon)
            events.append(BattleMessageEvent(message=application_message))
            
            events.append(VolatileStatusChangeEvent(
                pokemon=pokemon,
                status_logic_key=status_logic_key,
                is_applied=True,
                message=application_message
            ))
        
        return events

    def _is_immune_to_status(self, pokemon: Pokemon, status_logic_key: str) -> bool:
        """
        检查宝可梦是否免疫特定状态效果。
        
        Args:
            pokemon: 要检查的宝可梦
            status_logic_key: 状态效果的逻辑键
            
        Returns:
            如果宝可梦免疫该状态，则返回True；否则返回False
        """
        # 已有主要状态的宝可梦不能再有其他主要状态
        if status_logic_key in ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"] and pokemon.major_status:
            return True
        
        # 检查类型免疫
        pokemon_types = pokemon.types
        
        # 类型免疫规则
        type_immunities = {
            "poison": ["poison", "steel"],  # 毒系和钢系免疫中毒
            "toxic": ["poison", "steel"],   # 毒系和钢系免疫剧毒
            "paralysis": ["ground"],        # 地面系免疫麻痹（假设麻痹都是电系导致的）
            "burn": ["fire"],               # 火系免疫灼伤
            "freeze": ["ice"],              # 冰系免疫冰冻
            # 睡眠没有类型免疫
        }
        
        if status_logic_key in type_immunities:
            for immune_type in type_immunities[status_logic_key]:
                if immune_type in pokemon_types:
                    return True
        
        # 检查特性免疫
        ability = pokemon.ability
        if ability:
            ability_immunities = {
                "immunity": ["poison", "toxic"],
                "limber": ["paralysis"],
                "magma_armor": ["freeze"],
                "insomnia": ["sleep"],
                "vital_spirit": ["sleep"],
                "water_veil": ["burn"],
                # 添加更多特性免疫
            }
            
            if ability.ability_id in ability_immunities:
                if status_logic_key in ability_immunities[ability.ability_id]:
                    return True
        
        # 检查持有道具免疫
        held_item = pokemon.held_item
        if held_item:
            item_immunities = {
                "lum_berry": ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"],
                "cheri_berry": ["paralysis"],
                "chesto_berry": ["sleep"],
                "pecha_berry": ["poison", "toxic"],
                "rawst_berry": ["burn"],
                "aspear_berry": ["freeze"],
                # 添加更多道具免疫
            }
            
            if held_item.item_id in item_immunities:
                if status_logic_key in item_immunities[held_item.item_id]:
                    return True
        
        # 没有发现免疫
        return False

    # TODO: Add methods for removing status effects, processing end-of-turn effects, etc. (S130 refinement)
    # TODO: Add methods for processing volatile status effects at the start/end of a turn (e.g., confusion damage, flinch check) (S130 refinement) 