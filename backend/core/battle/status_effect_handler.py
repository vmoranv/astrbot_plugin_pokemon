import random # Import random for potential volatile status checks (e.g., confusion hit chance)
import math # Import math for confusion damage calculation
from typing import List, Dict, Any, Optional, Tuple, Callable, TYPE_CHECKING
if TYPE_CHECKING:
    from backend.models.battle import Battle
from backend.models.pokemon import Pokemon
from backend.models.status_effect import StatusEffect
from backend.core.battle.events import (
    BattleEvent, StatusEffectAppliedEvent, StatStageChangeEvent, BattleMessageEvent,
    StatusEffectRemovedEvent, DamageDealtEvent, ConfusionDamageEvent, # Import necessary events
    VolatileStatusChangeEvent, FlinchEvent # Import FlinchEvent
)
from backend.data_access.metadata_loader import MetadataRepository
from backend.utils.logger import get_logger
from backend.core.battle.formulas import calculate_damage, calculate_confusion_damage # Import the damage calculation function and calculate_confusion_damage

logger = get_logger(__name__)

class StatusEffectHandler:
    """
    Handles the application and management of status effects and stat stage changes
    during a battle.
    """
    def __init__(self, metadata_repo: MetadataRepository):
        """
        Initializes the StatusEffectHandler with necessary dependencies.

        Args:
            metadata_repo: The repository for accessing game metadata.
        """
        self._metadata_repo = metadata_repo
        # 易变状态处理器映射表
        self._volatile_status_handlers = {
            "confusion": self._handle_confusion,
            "flinch": self._handle_flinch,
            "infatuation": self._handle_infatuation,
            "taunt": self._handle_taunt,
            "encore": self._handle_encore,
            "trap": self._handle_trap,
            # 可根据需要添加更多处理器
        }

    def apply_status_effect(self, pokemon: Pokemon, status_effect: StatusEffect) -> List[BattleEvent]:
        """
        Attempts to apply a major status effect to a Pokemon, checking for immunities.

        Args:
            pokemon: The Pokemon to apply the status effect to.
            status_effect: The StatusEffect object to apply.

        Returns:
            A list of BattleEvent objects generated by the application attempt.
        """
        events: List[BattleEvent] = []

        # Check if the Pokemon already has a major status effect
        if pokemon.major_status_effect:
            message = f"{pokemon.nickname}已经处于{pokemon.major_status_effect.name}状态，无法再被施加新状态！"
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"Pokemon {pokemon.nickname} already has a major status effect: {pokemon.major_status_effect.name}")
            return events

        # Check for immunity based on item (S132 refinement - Item first)
        if self._metadata_repo.is_immune_by_item(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname}的{pokemon.held_item.name}使其免疫{status_effect.name}状态！" if pokemon.held_item else f"{pokemon.nickname}免疫{status_effect.name}状态！"
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to held item.")
             return events

        # Check for immunity based on ability (S132 refinement - Ability second)
        if self._metadata_repo.is_immune_by_ability(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname}的特性{pokemon.ability.name}使其免疫{status_effect.name}状态！" if pokemon.ability else f"{pokemon.nickname}免疫{status_effect.name}状态！"
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to ability.")
             return events

        # Check for immunity based on type (S132 refinement - Type last)
        if self._metadata_repo.is_immune_by_type(pokemon, status_effect.logic_key):
             message = f"{pokemon.nickname}的{', '.join([t.name for t in pokemon.types])}属性使其免疫{status_effect.name}状态！"
             events.append(BattleMessageEvent(message=message))
             logger.debug(f"Pokemon {pokemon.nickname} is immune to {status_effect.name} due to type.")
             return events

        # If not immune and no existing major status, apply the status effect
        pokemon.major_status_effect = status_effect
        
        # 根据状态效果类型设置合适的提示消息
        if status_effect.logic_key == "burn":
            message = f"{pokemon.nickname}被灼伤了！攻击力下降！"
        elif status_effect.logic_key == "paralysis":
            message = f"{pokemon.nickname}被麻痹了！速度下降！可能无法行动！"
        elif status_effect.logic_key == "poison":
            message = f"{pokemon.nickname}中毒了！将持续受到伤害！"
        elif status_effect.logic_key == "toxic":
            message = f"{pokemon.nickname}中了剧毒！伤害将逐渐加重！"
        elif status_effect.logic_key == "sleep":
            message = f"{pokemon.nickname}睡着了！无法行动！"
        elif status_effect.logic_key == "freeze":
            message = f"{pokemon.nickname}被冰冻了！无法行动！"
        else:
            message = f"{pokemon.nickname}{status_effect.name}了！"

        events.append(StatusEffectAppliedEvent(
            pokemon_instance_id=pokemon.instance_id,
            pokemon_name=pokemon.nickname,
            status_effect_id=status_effect.status_effect_id,
            status_effect_name=status_effect.name,
            status_effect_logic_key=status_effect.logic_key,
            message=message
        ))
        logger.debug(f"Applied {status_effect.name} to {pokemon.nickname}")

        # 应用特定状态效果的副作用
        if status_effect.logic_key == "burn":
            # 灼伤状态减半攻击
            stat_change_message = f"{pokemon.nickname}的攻击因灼伤而下降！"
            # 不是直接修改属性值，而是创建一个事件通知调用者
            burn_stat_event = StatStageChangeEvent(
                pokemon=pokemon,
                stat_name="attack",
                stages=-2,  # 减少2级（相当于攻击力减半）
                message=stat_change_message
            )
            events.append(burn_stat_event)
            logger.debug(f"Applied burn side effect: Attack halved for {pokemon.nickname}")
        elif status_effect.logic_key == "paralysis":
            # 麻痹状态减速
            stat_change_message = f"{pokemon.nickname}的速度因麻痹而下降！"
            paralysis_stat_event = StatStageChangeEvent(
                pokemon=pokemon,
                stat_name="speed",
                stages=-2,  # 减少2级（相当于速度减半）
                message=stat_change_message
            )
            events.append(paralysis_stat_event)
            logger.debug(f"Applied paralysis side effect: Speed halved for {pokemon.nickname}")
        elif status_effect.logic_key == "toxic":
            # 剧毒状态会逐渐加重伤害，需要设置一个计数器
            pokemon.status_counters["toxic_turns"] = 1
            logger.debug(f"Initialized toxic counter for {pokemon.nickname}")
        elif status_effect.logic_key == "sleep":
            message = f"{pokemon.nickname}睡着了！无法行动！"
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"Applied sleep side effect: Pokemon cannot act this turn")
        elif status_effect.logic_key == "freeze":
            message = f"{pokemon.nickname}被冰冻了！无法行动！"
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"Applied freeze side effect: Pokemon cannot act this turn")
        return events

    def remove_status_effect(self, pokemon: Pokemon, status_effect_logic_key: str = None) -> List[BattleEvent]:
        """
        Attempts to remove a major status effect from a Pokemon.

        Args:
            pokemon: The Pokemon to remove the status effect from.
            status_effect_logic_key: The logic key of the status effect to remove.

        Returns:
            A list of BattleEvent objects generated by the removal attempt.
        """
        events: List[BattleEvent] = []
        if not pokemon.major_status_effect:
            message = f"{pokemon.nickname}并没有{status_effect_logic_key}状态。"
            events.append(BattleMessageEvent(message=message))
            return events
        
        if status_effect_logic_key and pokemon.major_status_effect.logic_key != status_effect_logic_key:
            message = f"{pokemon.nickname}并没有{status_effect_logic_key}状态。"
            events.append(BattleMessageEvent(message=message))
            return events
        
        # 保存状态名称用于消息
        removed_status_name = pokemon.major_status_effect.name
        
        # 移除状态效果
        pokemon.major_status_effect = None
        
        # 如果是剧毒，移除计数器
        if status_effect_logic_key == "toxic" and "toxic_turns" in pokemon.status_counters:
            del pokemon.status_counters["toxic_turns"]
        
        # 创建状态移除事件
        message = f"{pokemon.nickname}的{removed_status_name}状态恢复了！"
        events.append(StatusEffectRemovedEvent(
            pokemon_instance_id=pokemon.instance_id,
            pokemon_name=pokemon.nickname,
            status_effect_name=removed_status_name,
            message=message
        ))
        
        logger.debug(f"Removed {removed_status_name} status from {pokemon.nickname}")
        
        return events

    def apply_volatile_status(self, pokemon: Pokemon, status_key: str, turns: int = None) -> List[BattleEvent]:
        """
        对宝可梦应用一个易变状态效果。

        Args:
            pokemon: 要应用状态效果的宝可梦
            status_key: 易变状态的逻辑键（如"confusion", "flinch"等）
            turns: 可选的持续回合数

        Returns:
            List[BattleEvent]: 应用状态效果产生的事件列表
        """
        events = []
        
        # 初始化易变状态字典（如果不存在）
        if not hasattr(pokemon, "volatile_status") or pokemon.volatile_status is None:
            pokemon.volatile_status = {}
        
        # 如果已经有这个状态，可能需要刷新或者不允许重复应用
        if status_key in pokemon.volatile_status:
            # 某些状态可以刷新持续时间，某些不能
            if status_key in ["taunt", "encore", "trap"]:
                pokemon.volatile_status[status_key]["turns_left"] = turns or pokemon.volatile_status[status_key]["turns_left"]
                message = f"{pokemon.nickname}的{status_key}状态持续时间被刷新！"
                events.append(BattleMessageEvent(message=message))
                return events
            else:
                message = f"{pokemon.nickname}已经处于{status_key}状态！"
                events.append(BattleMessageEvent(message=message))
                return events
        
        # 添加易变状态
        if status_key == "confusion":
            turns = turns or random.randint(2, 5)  # 混乱持续2-5回合
            pokemon.volatile_status["confusion"] = {"turns_left": turns}
            message = f"{pokemon.nickname}混乱了！"
        elif status_key == "flinch":
            # 畏缩只持续一回合，不需要turns参数
            pokemon.volatile_status["flinch"] = {"active": True}
            message = f"{pokemon.nickname}畏缩了！"
        elif status_key == "infatuation":
            pokemon.volatile_status["infatuation"] = {"active": True, "turns_left": turns or -1}  # -1表示无限期，直到一方离场
            message = f"{pokemon.nickname}着迷了！"
        elif status_key == "taunt":
            pokemon.volatile_status["taunt"] = {"turns_left": turns or 3}  # 嘲讽通常持续3回合
            message = f"{pokemon.nickname}被嘲讽了！"
        elif status_key == "encore":
            pokemon.volatile_status["encore"] = {"turns_left": turns or 3, "move_id": pokemon.last_used_move_id if hasattr(pokemon, "last_used_move_id") else None}
            message = f"{pokemon.nickname}被再来一次影响了！"
        elif status_key == "trap":
            pokemon.volatile_status["trap"] = {"turns_left": turns or random.randint(4, 5)}  # 束缚通常持续4-5回合
            message = f"{pokemon.nickname}被束缚住了！"
        else:
            pokemon.volatile_status[status_key] = {"active": True, "turns_left": turns or 1}
            message = f"{pokemon.nickname}受到了{status_key}状态的影响！"
        
        # 创建易变状态应用事件
        events.append(VolatileStatusChangeEvent(
            pokemon_instance_id=pokemon.instance_id,
            pokemon_name=pokemon.nickname,
            status_key=status_key,
            is_applied=True,
            message=message
        ))
        
        logger.debug(f"Applied volatile status {status_key} to {pokemon.nickname}")
        
        return events

    def remove_volatile_status(self, pokemon: Pokemon, status_key: str) -> List[BattleEvent]:
        """
        从宝可梦中移除一个易变状态效果。

        Args:
            pokemon: 要移除状态效果的宝可梦
            status_key: 要移除的易变状态的逻辑键

        Returns:
            List[BattleEvent]: 移除状态效果产生的事件列表
        """
        events = []
        
        # 检查宝可梦是否有易变状态字典
        if not hasattr(pokemon, "volatile_status") or pokemon.volatile_status is None or status_key not in pokemon.volatile_status:
            return events
        
        # 移除指定的易变状态
        del pokemon.volatile_status[status_key]
        
        # 创建易变状态移除事件
        message = f"{pokemon.nickname}的{status_key}状态解除了！"
        events.append(VolatileStatusChangeEvent(
            pokemon_instance_id=pokemon.instance_id,
            pokemon_name=pokemon.nickname,
            status_key=status_key,
            is_applied=False,
            message=message
        ))
        
        logger.debug(f"Removed volatile status {status_key} from {pokemon.nickname}")
        
        return events

    def apply_stat_stage_change(self, pokemon: Pokemon, stat_type: str, stages: int) -> List[BattleEvent]:
        """
        Applies a stat stage change to a Pokemon.

        Args:
            pokemon: The Pokemon whose stat stage is changing.
            stat_type: The type of stat changing (e.g., 'attack', 'defense').
            stages: The number of stages to change (positive for increase, negative for decrease).

        Returns:
            A list of BattleEvent objects generated by the change attempt.
        """
        events: List[BattleEvent] = []
        current_stage = pokemon.stat_stages.get(stat_type, 0)
        new_stage = max(-6, min(6, current_stage + stages)) # Stat stages are between -6 and +6

        if new_stage == current_stage:
            # No change occurred (e.g., already at +6 and tried to increase)
            message = f"{pokemon.nickname}的{stat_type}已经达到极限，无法再{'提高' if stages > 0 else '降低'}了！"
            events.append(BattleMessageEvent(message=message))
            return events

        pokemon.stat_stages[stat_type] = new_stage

        # 根据变化的级数调整消息
        if abs(stages) == 1:
            change_text = "提高" if stages > 0 else "降低"
        elif abs(stages) == 2:
            change_text = "大幅提高" if stages > 0 else "大幅降低"
        else:  # abs(stages) >= 3
            change_text = "巨幅提高" if stages > 0 else "巨幅降低"
            
        message = f"{pokemon.nickname}的{stat_type}{change_text}了！"

        events.append(StatStageChangeEvent(pokemon=pokemon, stat_type=stat_type, stages_changed=stages, new_stage=new_stage, message=message))

        return events

    def process_start_of_turn_volatile_effects(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        Processes volatile status effects that trigger at the start of a Pokemon's turn.

        Args:
            pokemon: The Pokemon whose volatile statuses are being processed.

        Returns:
            A list of BattleEvent objects generated by the volatile status effects.
        """
        events: List[BattleEvent] = []
        
        # 遍历所有易变状态，并使用对应的处理器处理
        for status in pokemon.volatile_statuses[:]:  # 创建副本以允许在迭代时修改
            handler = self._volatile_status_handlers.get(status.logic_key)
            if handler:
                status_events = handler(pokemon, status)
                events.extend(status_events)
        
        return events

    def process_end_of_turn_volatile_effects(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        Processes volatile status effects that trigger at the end of a Pokemon's turn.

        Args:
            pokemon: The Pokemon whose volatile statuses are being processed.

        Returns:
            A list of BattleEvent objects generated by the volatile status effects.
        """
        events: List[BattleEvent] = []
        
        # 遍历所有易变状态，减少持续回合并检查是否到期
        for status in pokemon.volatile_statuses[:]:  # 创建副本以允许在迭代时删除
            if status.remaining_turns > 0:
                status.remaining_turns -= 1
                
            if status.remaining_turns <= 0:
                # 状态到期，移除它
                pokemon.volatile_statuses.remove(status)
                
                # 添加状态移除消息和事件
                status_message = self._get_status_removal_message(status.logic_key, pokemon)
                events.append(BattleMessageEvent(message=status_message))
                
                events.append(VolatileStatusChangeEvent(
                    pokemon=pokemon,
                    status_logic_key=status.logic_key,
                    is_applied=False,
                    message=status_message
                ))
                
                logger.info(f"{status.logic_key} status expired for {pokemon.nickname}")
                
        return events

    # ===== 各种易变状态的处理器 =====
    
    def _handle_confusion(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理混乱状态"""
        events: List[BattleEvent] = []
        
        # 混乱状态的效果处理
        # 1/3 的几率混乱命中自己
        if random.random() < 1/3:  # 33% 几率混乱导致自伤
            # 计算混乱伤害
            confusion_damage = calculate_confusion_damage(pokemon)
            
            # 应用混乱伤害
            pokemon.current_hp = max(0, pokemon.current_hp - confusion_damage)
            
            # 创建混乱伤害事件
            events.append(ConfusionDamageEvent(
                pokemon=pokemon,
                damage=confusion_damage,
                message=f"{pokemon.nickname} 混乱了！它攻击了自己，造成了 {confusion_damage} 点伤害！"
            ))
            
            logger.info(f"{pokemon.nickname} hit itself in confusion for {confusion_damage} damage")
        else:
            # 混乱但本回合没有自伤
            events.append(BattleMessageEvent(
                message=f"{pokemon.nickname} 混乱了，但它仍然能够行动！"
            ))
            
            logger.info(f"{pokemon.nickname} is confused but did not hit itself this turn")
            
        return events
        
    def _handle_flinch(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理畏缩状态"""
        events: List[BattleEvent] = []
        
        # 畏缩导致无法行动
        message = f"{pokemon.nickname}因畏缩而无法行动！"
        events.append(BattleMessageEvent(message=message))
        events.append(FlinchEvent(pokemon=pokemon))
        
        # 畏缩只持续一回合，使用后立即移除
        pokemon.volatile_statuses.remove(status)
        
        return events
        
    def _handle_infatuation(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理迷恋状态"""
        events: List[BattleEvent] = []
        
        # 迷恋状态在check_can_act中检查是否导致无法行动
        # 这里可以添加一些视觉或提示效果
        message = f"{pokemon.nickname}被迷住了！"
        events.append(BattleMessageEvent(message=message))
        
        return events
        
    def _handle_taunt(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理挑衅状态"""
        events: List[BattleEvent] = []
        
        # 挑衅状态的效果（禁止使用非攻击性技能）会在技能选择阶段检查
        message = f"{pokemon.nickname}被挑衅了，只能使用攻击性技能！"
        events.append(BattleMessageEvent(message=message))
        
        return events
        
    def _handle_encore(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理鼓掌状态"""
        events: List[BattleEvent] = []
        
        # 鼓掌效果（强制使用最后一次使用的技能）会在技能选择阶段处理
        last_skill = status.custom_data.get("last_skill")
        if last_skill:
            message = f"{pokemon.nickname}受到鼓掌效果，必须使用{last_skill}！"
        else:
            message = f"{pokemon.nickname}受到鼓掌效果！"
        events.append(BattleMessageEvent(message=message))
        
        return events
    
    def _handle_trap(self, pokemon: Pokemon, status: StatusEffect) -> List[BattleEvent]:
        """处理束缚状态"""
        events: List[BattleEvent] = []
        
        # 计算束缚伤害
        max_hp = pokemon.get_stat("hp")
        trap_damage = max(1, max_hp // 16)  # 至少1点伤害
        
        # 应用伤害
        old_hp = pokemon.current_hp
        pokemon.current_hp = max(0, pokemon.current_hp - trap_damage)
        
        # 获取束缚来源（如果有）
        source = status.custom_data.get("source", "")
        trap_type = status.custom_data.get("trap_type", "束缚")
        
        message = f"{pokemon.nickname}受到了{trap_type}的伤害！"
        events.append(BattleMessageEvent(message=message))
        
        events.append(DamageDealtEvent(
            pokemon=pokemon,
            damage=trap_damage,
            old_hp=old_hp,
            new_hp=pokemon.current_hp,
            damage_source="trap"
        ))
        
        return events
    
    # ===== 辅助方法 =====
    
    def _get_status_application_message(self, status_logic_key: str, pokemon: Pokemon) -> str:
        """获取状态施加时的消息"""
        status_messages = {
            "confusion": f"{pokemon.nickname} 混乱了！",
            "flinch": f"{pokemon.nickname} 畏缩了！",
            "infatuation": f"{pokemon.nickname}被迷住了！",
            "taunt": f"{pokemon.nickname} 被挑衅了！",
            "encore": f"{pokemon.nickname} 被鼓掌了！",
            # 可根据需要添加更多状态消息
        }
        
        return status_messages.get(status_logic_key, f"{pokemon.nickname} 受到了 {status_logic_key} 状态的影响！")
        
    def _get_status_removal_message(self, status_logic_key: str, pokemon: Pokemon) -> str:
        """获取状态移除时的消息"""
        status_messages = {
            "confusion": f"{pokemon.nickname} 不再混乱了！",
            "flinch": f"{pokemon.nickname} 不再畏缩了！",
            "infatuation": f"{pokemon.nickname}不再被迷住了！",
            "taunt": f"{pokemon.nickname} 不再被挑衅了！",
            "encore": f"{pokemon.nickname} 不再被鼓掌约束了！",
            # 可根据需要添加更多状态消息
        }
        
        return status_messages.get(status_logic_key, f"{pokemon.nickname} 不再受到 {status_logic_key} 状态的影响！")

    def check_can_act(self, pokemon: Pokemon) -> Tuple[bool, Optional[BattleEvent]]:
        """
        检查宝可梦是否可以在本回合采取行动。
        某些状态效果（如睡眠、冰冻）会阻止宝可梦行动。
        
        Args:
            pokemon: 要检查的宝可梦
            
        Returns:
            元组(can_act, event)，can_act为True表示可以行动，False表示不能行动
            如果不能行动，event包含相应的战斗事件（如消息事件）
        """
        # 检查主要状态效果
        if pokemon.major_status_effect:
            # 冰冻状态：通常无法行动，但有10%的几率解冻
            if pokemon.major_status_effect.effect_logic_key == "frozen":
                # 10%的几率自然解冻
                if random.random() < 0.1:
                    # 解除冰冻状态
                    status = pokemon.major_status_effect
                    pokemon.major_status_effect = None
                    message = f"{pokemon.nickname}解冻了！"
                    event = StatusEffectRemovedEvent(
                        pokemon=pokemon,
                        status_logic_key=status.effect_logic_key,
                        message=message
                    )
                    return True, event
                else:
                    # 仍然冰冻，无法行动
                    message = f"{pokemon.nickname}被冰冻住了，无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
                
            # 睡眠状态：无法行动，但可能在回合结束时醒来
            elif pokemon.major_status_effect.effect_logic_key == "sleep":
                # 处理睡眠回合减少逻辑在process_end_of_turn_major_status中
                message = f"{pokemon.nickname}正在睡觉，无法行动！"
                event = BattleMessageEvent(message=message)
                return False, event
            
            # 麻痹状态：25%几率无法行动
            elif pokemon.major_status_effect.effect_logic_key == "paralysis":
                if random.random() < 0.25:  # 25%几率无法行动
                    message = f"{pokemon.nickname}因麻痹无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
        
        # 检查易变状态中的限制
        for status in pokemon.volatile_statuses:
            if status.effect_logic_key == "infatuation":
                # 50%几率因迷恋而无法行动
                if random.random() < 0.5:
                    message = f"{pokemon.nickname}因为迷恋无法行动！"
                    event = BattleMessageEvent(message=message)
                    return False, event
                
        # 没有阻止行动的状态效果
        return True, None

    def process_end_of_turn_major_status(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        处理回合结束时主要状态效果的变化（如中毒伤害、烧伤伤害、睡眠回合减少等）。
        
        Args:
            pokemon: 要处理状态效果的宝可梦
            
        Returns:
            产生的战斗事件列表
        """
        events: List[BattleEvent] = []
        
        if not pokemon.major_status_effect:
            return events
        
        status = pokemon.major_status_effect
        
        # 处理中毒状态（扣除最大HP的1/8）
        if status.effect_logic_key == "poison":
            # 计算中毒伤害
            max_hp = pokemon.get_stat("hp")
            poison_damage = max(1, max_hp // 8)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - poison_damage)
            
            message = f"{pokemon.nickname}受到了中毒伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=poison_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="poison"
            ))
            
        # 处理剧毒状态（扣除递增的HP）
        elif status.effect_logic_key == "toxic":
            # 获取或初始化剧毒回合计数
            turn_count = status.custom_data.get("turn_count", 1)
            
            # 计算剧毒伤害（初始1/16，每回合递增1/16）
            max_hp = pokemon.get_stat("hp")
            toxic_damage = max(1, (max_hp * turn_count) // 16)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - toxic_damage)
            
            message = f"{pokemon.nickname}受到了剧毒伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=toxic_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="toxic"
            ))
            
            # 更新剧毒回合计数
            status.custom_data["turn_count"] = turn_count + 1
            
        # 处理灼伤状态（扣除最大HP的1/8，物理攻击降低）
        elif status.effect_logic_key == "burn":
            # 计算灼伤伤害
            max_hp = pokemon.get_stat("hp")
            burn_damage = max(1, max_hp // 8)  # 至少1点伤害
            
            # 应用伤害
            old_hp = pokemon.current_hp
            pokemon.current_hp = max(0, pokemon.current_hp - burn_damage)
            
            message = f"{pokemon.nickname}受到了灼伤伤害！"
            events.append(BattleMessageEvent(message=message))
            
            events.append(DamageDealtEvent(
                pokemon=pokemon,
                damage=burn_damage,
                old_hp=old_hp,
                new_hp=pokemon.current_hp,
                damage_source="burn"
            ))
        
        # 处理睡眠状态（回合减少，可能醒来）
        elif status.effect_logic_key == "sleep":
            # 获取或初始化剩余睡眠回合
            remaining_turns = status.remaining_turns
            
            if remaining_turns <= 0:
                # 初始化剩余回合（如果没有设置）
                remaining_turns = random.randint(1, 3)
                status.remaining_turns = remaining_turns
            
            # 减少剩余回合
            status.remaining_turns -= 1
            
            # 检查是否应该醒来
            if status.remaining_turns <= 0:
                # 移除睡眠状态
                pokemon.major_status_effect = None
                
                message = f"{pokemon.nickname}醒来了！"
                events.append(BattleMessageEvent(message=message))
                
                events.append(StatusEffectRemovedEvent(
                    pokemon=pokemon,
                    status_logic_key="sleep",
                    message=message
                ))
        
        return events

    def apply_status_effect(self, pokemon: Pokemon, status_logic_key: str, turns: int = -1, custom_data: Dict[str, Any] = None) -> List[BattleEvent]:
        """
        为宝可梦施加状态效果。
        
        Args:
            pokemon: 施加状态效果的目标宝可梦
            status_logic_key: 状态效果的逻辑键
            turns: 状态效果持续的回合数（-1表示无限持续）
            custom_data: 与状态相关的自定义数据
            
        Returns:
            产生的战斗事件列表
        """
        events: List[BattleEvent] = []
        
        # 检查是否免疫该状态
        if self._is_immune_to_status(pokemon, status_logic_key):
            message = f"{pokemon.nickname}免疫{status_logic_key}状态！"
            events.append(BattleMessageEvent(message=message))
            return events
        
        # 区分主要状态效果和易变状态效果
        if status_logic_key in ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"]:
            # 主要状态效果（宝可梦一次只能有一个）
            
            # 如果已经有主要状态，先移除
            if pokemon.major_status_effect:
                old_status = pokemon.major_status_effect
                pokemon.major_status_effect = None
                
                removal_message = self._get_status_removal_message(old_status.effect_logic_key, pokemon)
                events.append(BattleMessageEvent(message=removal_message))
                
                events.append(StatusEffectRemovedEvent(
                    pokemon=pokemon,
                    status_logic_key=old_status.effect_logic_key,
                    message=removal_message
                ))
            
            # 创建新的状态效果
            status_metadata = self._metadata_repo.get_status_effect_by_logic_key(status_logic_key)
            if not status_metadata:
                logger.error(f"未找到状态效果元数据：{status_logic_key}")
                return events
            
            status = StatusEffect(
                status_effect_id=status_metadata["id"],
                name=status_metadata["name"],
                description=status_metadata.get("description", ""),
                effect_logic_key=status_logic_key,
                remaining_turns=turns,
                custom_data=custom_data or {}
            )
            
            # 应用主要状态
            pokemon.major_status_effect = status
            
            # 生成应用消息和事件
            application_message = self._get_status_application_message(status_logic_key, pokemon)
            events.append(BattleMessageEvent(message=application_message))
            
            events.append(StatusEffectAppliedEvent(
                pokemon=pokemon,
                status_logic_key=status_logic_key,
                message=application_message
            ))
            
        else:
            # 易变状态效果（宝可梦可以同时拥有多个）
            
            # 检查是否已经有该状态
            for existing_status in pokemon.volatile_statuses:
                if existing_status.effect_logic_key == status_logic_key:
                    # 已存在该状态，更新持续回合
                    existing_status.remaining_turns = turns
                    return events
            
            # 创建新的状态效果
            status_metadata = self._metadata_repo.get_status_effect_by_logic_key(status_logic_key)
            if not status_metadata:
                logger.error(f"未找到状态效果元数据：{status_logic_key}")
                return events
            
            status = StatusEffect(
                status_effect_id=status_metadata["id"],
                name=status_metadata.get("name", status_logic_key),
                description=status_metadata.get("description", ""),
                effect_logic_key=status_logic_key,
                remaining_turns=turns,
                custom_data=custom_data or {}
            )
            
            # 添加易变状态
            pokemon.volatile_statuses.append(status)
            
            # 生成应用消息和事件
            application_message = self._get_status_application_message(status_logic_key, pokemon)
            events.append(BattleMessageEvent(message=application_message))
            
            events.append(VolatileStatusChangeEvent(
                pokemon=pokemon,
                status_logic_key=status_logic_key,
                is_applied=True,
                message=application_message
            ))
        
        return events

    def _is_immune_to_status(self, pokemon: Pokemon, status_logic_key: str) -> bool:
        """
        检查宝可梦是否免疫特定状态效果。
        
        Args:
            pokemon: 要检查的宝可梦
            status_logic_key: 状态效果的逻辑键
            
        Returns:
            如果宝可梦免疫该状态，则返回True；否则返回False
        """
        # 已有主要状态的宝可梦不能再有其他主要状态
        if status_logic_key in ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"] and pokemon.major_status_effect:
            return True
        
        # 检查类型免疫
        pokemon_types = pokemon.types
        
        # 类型免疫规则
        type_immunities = {
            "poison": ["poison", "steel"],  # 毒系和钢系免疫中毒
            "toxic": ["poison", "steel"],   # 毒系和钢系免疫剧毒
            "paralysis": ["ground"],        # 地面系免疫麻痹（假设麻痹都是电系导致的）
            "burn": ["fire"],               # 火系免疫灼伤
            "freeze": ["ice"],              # 冰系免疫冰冻
            # 睡眠没有类型免疫
        }
        
        if status_logic_key in type_immunities:
            for immune_type in type_immunities[status_logic_key]:
                if immune_type in pokemon_types:
                    return True
        
        # 检查特性免疫
        ability = pokemon.ability
        if ability:
            ability_immunities = {
                "immunity": ["poison", "toxic"],
                "limber": ["paralysis"],
                "magma_armor": ["freeze"],
                "insomnia": ["sleep"],
                "vital_spirit": ["sleep"],
                "water_veil": ["burn"],
                # 添加更多特性免疫
            }
            
            if ability.ability_id in ability_immunities:
                if status_logic_key in ability_immunities[ability.ability_id]:
                    return True
        
        # 检查持有道具免疫
        held_item = pokemon.held_item
        if held_item:
            item_immunities = {
                "lum_berry": ["poison", "toxic", "burn", "paralysis", "sleep", "freeze"],
                "cheri_berry": ["paralysis"],
                "chesto_berry": ["sleep"],
                "pecha_berry": ["poison", "toxic"],
                "rawst_berry": ["burn"],
                "aspear_berry": ["freeze"],
                # 添加更多道具免疫
            }
            
            if held_item.item_id in item_immunities:
                if status_logic_key in item_immunities[held_item.item_id]:
                    return True
        
        # 没有发现免疫
        return False

    async def process_status_end_of_turn(self, pokemon: Pokemon, battle: Optional['Battle'] = None) -> List[BattleEvent]:
        """
        处理宝可梦在回合结束时的状态效果，如毒素伤害、灼伤伤害等。

        Args:
            pokemon: 需要处理状态效果的宝可梦
            battle: 可选的战斗对象，用于获取场地等信息

        Returns:
            List[BattleEvent]: 处理状态产生的事件列表
        """
        events = []
        
        if not pokemon.major_status_effect:
            return events
        
        status_key = pokemon.major_status_effect.effect_logic_key
        
        # 处理中毒状态伤害
        if status_key == "poison":
            max_hp = pokemon.get_stat("hp")
            damage = max(1, max_hp // 8)  # 每回合损失最大HP的1/8，最少1点
            
            # 创建伤害事件
            message = f"{pokemon.nickname}受到了毒素伤害！"
            poison_damage_event = DamageDealtEvent(
                target_instance_id=pokemon.instance_id,
                target_name=pokemon.nickname,
                damage=damage,
                remaining_hp=max(0, pokemon.current_hp - damage),
                max_hp=max_hp,
                damage_type="status",
                effectiveness=1.0,
                is_critical=False,
                message=message
            )
            events.append(poison_damage_event)
            logger.debug(f"Applied poison damage ({damage}) to {pokemon.nickname}")
            
        # 处理剧毒状态伤害（随回合增加）
        elif status_key == "toxic":
            if "toxic_turns" not in pokemon.status_counters:
                pokemon.status_counters["toxic_turns"] = 1
            
            max_hp = pokemon.get_stat("hp")
            toxic_turn = pokemon.status_counters["toxic_turns"]
            # 剧毒伤害随回合增加：N/16 * 最大HP（N是回合数）
            damage = max(1, (max_hp * toxic_turn) // 16)
            
            # 创建伤害事件
            message = f"{pokemon.nickname}受到了剧毒伤害！"
            toxic_damage_event = DamageDealtEvent(
                target_instance_id=pokemon.instance_id,
                target_name=pokemon.nickname,
                damage=damage,
                remaining_hp=max(0, pokemon.current_hp - damage),
                max_hp=max_hp,
                damage_type="status",
                effectiveness=1.0,
                is_critical=False,
                message=message
            )
            events.append(toxic_damage_event)
            
            # 增加计数器
            pokemon.status_counters["toxic_turns"] = min(15, toxic_turn + 1)  # 最多15回合
            logger.debug(f"Applied toxic damage ({damage}) to {pokemon.nickname} (turn {toxic_turn})")
        
        # 处理灼伤状态伤害
        elif status_key == "burn":
            max_hp = pokemon.get_stat("hp")
            damage = max(1, max_hp // 16)  # 每回合损失最大HP的1/16，最少1点
            
            # 创建伤害事件
            message = f"{pokemon.nickname}受到了灼伤伤害！"
            burn_damage_event = DamageDealtEvent(
                target_instance_id=pokemon.instance_id,
                target_name=pokemon.nickname,
                damage=damage,
                remaining_hp=max(0, pokemon.current_hp - damage),
                max_hp=max_hp,
                damage_type="status",
                effectiveness=1.0,
                is_critical=False,
                message=message
            )
            events.append(burn_damage_event)
            logger.debug(f"Applied burn damage ({damage}) to {pokemon.nickname}")
        
        # 处理睡眠状态（睡眠回合递减）
        elif status_key == "sleep":
            if "sleep_turns" not in pokemon.status_counters:
                # 初始化为2-5回合的随机值
                pokemon.status_counters["sleep_turns"] = random.randint(2, 5)
                
            sleep_turns = pokemon.status_counters["sleep_turns"]
            sleep_turns -= 1
            
            if sleep_turns <= 0:
                # 睡眠结束
                events.extend(self.remove_status_effect(pokemon, "sleep"))
            else:
                # 更新剩余回合
                pokemon.status_counters["sleep_turns"] = sleep_turns
                logger.debug(f"{pokemon.nickname} will be asleep for {sleep_turns} more turns")
        
        # 处理冰冻状态（每回合有20%几率解除）
        elif status_key == "freeze":
            # 20%几率自然解冻
            if random.random() < 0.2:
                events.extend(self.remove_status_effect(pokemon, "freeze"))
                logger.debug(f"{pokemon.nickname} thawed out!")
        
        return events

    async def process_status_start_of_turn(self, pokemon: Pokemon, battle: Optional['Battle'] = None) -> List[BattleEvent]:
        """
        处理宝可梦在回合开始时的状态效果，如睡眠、冰冻等可能导致无法行动的状态。

        Args:
            pokemon: 需要处理状态效果的宝可梦
            battle: 可选的战斗对象，用于获取场地等信息

        Returns:
            List[BattleEvent]: 处理状态产生的事件列表，可能包含"无法行动"的事件
        """
        events = []
        
        if not pokemon.major_status_effect:
            return events
        
        status_key = pokemon.major_status_effect.effect_logic_key
        
        # 处理麻痹状态（25%几率无法行动）
        if status_key == "paralysis":
            if random.random() < 0.25:  # 25%几率无法行动
                message = f"{pokemon.nickname}因麻痹而无法行动！"
                events.append(BattleMessageEvent(message=message))
                # 添加一个专门的"无法行动"事件
                events.append(FlinchEvent(
                    pokemon_instance_id=pokemon.instance_id,
                    pokemon_name=pokemon.nickname,
                    message=message
                ))
                logger.debug(f"{pokemon.nickname} is paralyzed and cannot move")
        
        # 处理睡眠状态（无法行动）
        elif status_key == "sleep":
            message = f"{pokemon.nickname}正在睡觉！"
            events.append(BattleMessageEvent(message=message))
            # 添加一个专门的"无法行动"事件
            events.append(FlinchEvent(
                pokemon_instance_id=pokemon.instance_id,
                pokemon_name=pokemon.nickname,
                message=message
            ))
            logger.debug(f"{pokemon.nickname} is sleeping and cannot move")
            
        # 冰冻状态无法行动
        elif status_key == "freeze":
            message = f"{pokemon.nickname}被冰冻住了！"
            events.append(BattleMessageEvent(message=message))
            # 添加一个专门的"无法行动"事件
            events.append(FlinchEvent(
                pokemon_instance_id=pokemon.instance_id,
                pokemon_name=pokemon.nickname,
                message=message
            ))
            logger.debug(f"{pokemon.nickname} is frozen and cannot move")
        
        return events

    async def _handle_confusion(self, pokemon: Pokemon, battle: Optional['Battle'] = None, phase: str = "action") -> List[BattleEvent]:
        """
        处理混乱状态的效果。

        Args:
            pokemon: 处于混乱状态的宝可梦
            battle: 当前战斗
            phase: 当前处理的阶段，可能是"start_of_turn"、"action"或"end_of_turn"

        Returns:
            List[BattleEvent]: 处理混乱状态产生的事件列表
        """
        events = []
        
        if phase != "action":
            return events  # 混乱只在行动阶段检查
        
        confusion_data = pokemon.volatile_status.get("confusion", {})
        if not confusion_data.get("active", False):
            return events
        
        # 混乱持续2-5回合
        turns_left = confusion_data.get("turns_left", 0)
        if turns_left <= 0:
            # 混乱结束
            pokemon.volatile_status["confusion"]["active"] = False
            message = f"{pokemon.nickname}的混乱状态解除了！"
            events.append(VolatileStatusChangeEvent(
                pokemon=pokemon,
                status_key="confusion",
                is_applied=False,
                message=message
            ))
            logger.debug(f"{pokemon.nickname}'s confusion ended")
            return events
        
        # 减少剩余回合
        pokemon.volatile_status["confusion"]["turns_left"] = turns_left - 1
        
        # 混乱有50%几率自伤
        if random.random() < 0.5:
            # 计算自伤伤害（基于宝可梦自身的攻击力，使用特殊的混乱伤害公式）
            attack_stat = pokemon.get_stat("attack")
            defense_stat = pokemon.get_stat("defense")
            level = pokemon.level
            
            # 混乱伤害公式：((2 * Level / 5 + 2) * 40 * Attack / Defense) / 50 + 2
            base_damage = ((2 * level / 5 + 2) * 40 * attack_stat / defense_stat) / 50 + 2
            # 添加0.85-1.0的随机修正
            damage = int(base_damage * random.uniform(0.85, 1.0))
            damage = max(1, damage)  # 至少造成1点伤害
            
            events.append(DamageDealtEvent(
                target_instance_id=pokemon.instance_id,
                target_name=pokemon.nickname,
                damage=damage,
                remaining_hp=max(0, pokemon.current_hp - damage),
                max_hp=pokemon.get_stat("hp"),
                damage_type="confusion",
                effectiveness=1.0,
                is_critical=False,
                message=f"{pokemon.nickname}混乱中伤到了自己！"
            ))
            
            # 添加一个行动失败事件
            events.append(FlinchEvent(
                pokemon_instance_id=pokemon.instance_id,
                pokemon_name=pokemon.nickname,
                message=f"{pokemon.nickname}因混乱而无法使用技能！"
            ))
            
            logger.debug(f"{pokemon.nickname} hurt itself in confusion for {damage} damage")
        else:
            message = f"{pokemon.nickname}混乱中！"
            events.append(BattleMessageEvent(message=message))
            logger.debug(f"{pokemon.nickname} is confused but can still move")
        
        return events 

    async def process_volatile_status_start_of_turn(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        处理宝可梦在回合开始时的易变状态效果。

        Args:
            pokemon: 需要处理状态效果的宝可梦

        Returns:
            List[BattleEvent]: 处理状态产生的事件列表
        """
        events = []
        
        # 检查宝可梦是否有易变状态
        if not hasattr(pokemon, "volatile_status") or not pokemon.volatile_status:
            return events
        
        # 处理畏缩状态（回合开始时清除）
        if "flinch" in pokemon.volatile_status:
            events.extend(self.remove_volatile_status(pokemon, "flinch"))
        
        # 这里可以添加其他需要在回合开始时处理的易变状态
        
        return events 

    async def process_volatile_status_end_of_turn(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        处理宝可梦在回合结束时的易变状态效果。

        Args:
            pokemon: 需要处理状态效果的宝可梦

        Returns:
            List[BattleEvent]: 处理状态产生的事件列表
        """
        events = []
        
        # 检查宝可梦是否有易变状态
        if not hasattr(pokemon, "volatile_status") or not pokemon.volatile_status:
            return events
        
        # 处理持续回合的易变状态
        volatile_status_to_process = list(pokemon.volatile_status.keys())
        
        for status_key in volatile_status_to_process:
            if status_key == "confusion":
                events.extend(self._process_confusion_end_of_turn(pokemon))
            elif status_key in ["taunt", "encore", "trap"]:
                # 减少剩余回合数
                if "turns_left" in pokemon.volatile_status[status_key]:
                    turns_left = pokemon.volatile_status[status_key]["turns_left"]
                    if turns_left > 0:
                        pokemon.volatile_status[status_key]["turns_left"] = turns_left - 1
                        logger.debug(f"{pokemon.nickname}'s {status_key} has {turns_left-1} turns left")
                    
                    # 如果回合数归零，移除状态
                    if pokemon.volatile_status[status_key]["turns_left"] <= 0:
                        events.extend(self.remove_volatile_status(pokemon, status_key))
        
        return events

    def _process_confusion_end_of_turn(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        处理宝可梦在回合结束时的混乱状态。

        Args:
            pokemon: 需要处理混乱状态的宝可梦

        Returns:
            List[BattleEvent]: 处理混乱状态产生的事件列表
        """
        events = []
        
        # 检查宝可梦是否有混乱状态
        if "confusion" not in pokemon.volatile_status:
            return events
        
        # 获取剩余混乱回合
        turns_left = pokemon.volatile_status["confusion"]["turns_left"]
        
        # 如果回合数归零，移除混乱状态
        if turns_left <= 0:
            message = f"{pokemon.nickname}恢复了清醒！"
            events.extend(self.remove_volatile_status(pokemon, "confusion"))
            events.append(BattleMessageEvent(
                message=message
            ))
            logger.debug(f"{pokemon.nickname}'s confusion ended")
            return events
        
        # 减少剩余回合
        pokemon.volatile_status["confusion"]["turns_left"] = turns_left - 1
        logger.debug(f"{pokemon.nickname} will be confused for {turns_left-1} more turns")
        
        return events

    def apply_confusion(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        对宝可梦应用混乱状态。
        
        Args:
            pokemon: 要应用混乱状态的宝可梦
            
        Returns:
            List[BattleEvent]: 应用混乱状态产生的事件列表
        """
        events = []
        
        # 检查宝可梦是否已经混乱
        if hasattr(pokemon, "volatile_status") and pokemon.volatile_status and "confusion" in pokemon.volatile_status:
            message = f"{pokemon.nickname}已经处于混乱状态！"
            events.append(BattleMessageEvent(message=message))
            return events
        
        # 初始化易变状态字典（如果不存在）
        if not hasattr(pokemon, "volatile_status") or pokemon.volatile_status is None:
            pokemon.volatile_status = {}
        
        # 应用混乱状态（持续2-5回合）
        confusion_turns = random.randint(2, 5)
        pokemon.volatile_status["confusion"] = {"active": True, "turns_left": confusion_turns}
        
        # 创建混乱状态应用事件
        message = f"{pokemon.nickname}混乱了！"
        events.append(VolatileStatusChangeEvent(
            pokemon_instance_id=pokemon.instance_id,
            pokemon_name=pokemon.nickname,
            status_key="confusion",
            is_applied=True,
            message=message
        ))
        
        logger.debug(f"Applied confusion to {pokemon.nickname} for {confusion_turns} turns")
        
        return events

    def has_status_effect(self, pokemon: Pokemon, status_logic_key: str, volatile: bool = False) -> bool:
        """
        检查宝可梦是否有指定的状态效果。
        
        Args:
            pokemon: 要检查的宝可梦
            status_logic_key: 状态效果的逻辑键
            volatile: 是否检查易变状态
            
        Returns:
            bool: 如果宝可梦有指定状态效果，则返回True；否则返回False
        """
        if volatile:
            # 检查易变状态
            if not hasattr(pokemon, "volatile_status") or not pokemon.volatile_status:
                return False
            return status_logic_key in pokemon.volatile_status
        else:
            # 检查主要状态
            if not pokemon.major_status_effect:
                return False
            return pokemon.major_status_effect.logic_key == status_logic_key