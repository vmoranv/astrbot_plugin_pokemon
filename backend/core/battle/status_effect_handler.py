import random # Import random for potential volatile status checks (e.g., confusion hit chance)
from typing import List, Dict, Any, Optional, Tuple
from backend.models.pokemon import Pokemon
from backend.models.status_effect import StatusEffect
from backend.core.battle.events import (
    BattleEvent, StatusEffectAppliedEvent, StatStageChangeEvent, BattleMessageEvent,
    StatusEffectRemovedEvent, DamageDealtEvent, ConfusionDamageEvent # Import necessary events
)
from backend.data_access.metadata_loader import MetadataRepository
from backend.utils.logger import get_logger
from backend.core.formulas import calculate_damage # Import the damage calculation function

logger = get_logger(__name__)

class StatusEffectHandler:
    """
    Handles the application and management of status effects and stat stage changes
    during a battle.
    """
    def __init__(self, metadata_repo: MetadataRepository):
        """
        Initializes the StatusEffectHandler with necessary dependencies.

        Args:
            metadata_repo: The repository for accessing game metadata.
        """
        self._metadata_repo = metadata_repo

    def apply_status_effect(self, pokemon: Pokemon, status_effect: StatusEffect) -> List[BattleEvent]:
        """
        Applies a status effect to a Pokemon, including immunity checks.

        Args:
            pokemon: The Pokemon to apply the status effect to.
            status_effect: The StatusEffect to apply.

        Returns:
            A list of BattleEvent objects generated by the application attempt.
        """
        events: List[BattleEvent] = []

        # S127: Check for status immunities based on type, ability, and item
        # Check type immunity
        if status_effect.logic_key == 'poison' and any(t.attribute_name == '毒' for t in pokemon.types):
            events.append(BattleMessageEvent(message=f"{pokemon.nickname} 是毒属性，不受中毒影响！"))
            return events
        if status_effect.logic_key == 'paralysis' and any(t.attribute_name == '电' for t in pokemon.types):
             events.append(BattleMessageEvent(message=f"{pokemon.nickname} 是电属性，不受麻痹影响！"))
             return events
        if status_effect.logic_key == 'burn' and any(t.attribute_name == '火' for t in pokemon.types):
             events.append(BattleMessageEvent(message=f"{pokemon.nickname} 是火属性，不受灼伤影响！"))
             return events
        if status_effect.logic_key == 'freeze' and any(t.attribute_name == '冰' for t in pokemon.types):
             events.append(BattleMessageEvent(message=f"{pokemon.nickname} 是冰属性，不受冰冻影响！"))
             return events
        # TODO: Add other type immunities if any (e.g., Steel type immunity to Poison) (S127 refinement)
        if status_effect.logic_key == 'poison' and any(t.attribute_name == '钢' for t in pokemon.types):
             events.append(BattleMessageEvent(message=f"{pokemon.nickname} 是钢属性，不受中毒影响！"))
             return events

        # Check ability and item immunity using MetadataRepository
        if self._metadata_repo.check_status_immunity_by_ability_or_item(pokemon, status_effect.logic_key):
             # The check_status_immunity_by_ability_or_item method already logs the reason
             return events # Return empty events list as status was not applied

        # S124: Check if target already has a major status effect
        if status_effect.effect_type == 'major' and pokemon.status_effect is not None:
            events.append(BattleMessageEvent(message=f"{pokemon.nickname} 已经处于 {pokemon.status_effect.name} 状态，无法再施加 {status_effect.name}！")) # TODO: Refine message
            return events

        # Apply the status effect
        if status_effect.effect_type == 'major':
            pokemon.status_effect = status_effect
            # Initialize turn counters for sleep/freeze (S131 refinement)
            if status_effect.logic_key == 'sleep':
                # Sleep duration is usually 1-4 turns in main series games
                # TODO: Make sleep duration range configurable (S131 refinement)
                pokemon.sleep_turns = random.randint(1, 4)
                logger.debug(f"Pokemon {pokemon.nickname} fell asleep for {pokemon.sleep_turns} turns.")
            elif status_effect.logic_key == 'freeze':
                 # Freeze usually has a 20% chance to thaw each turn
                 # TODO: Make freeze thaw chance configurable (S131 refinement)
                 pokemon.freeze_turns = 0 # Initialize freeze turns counter
                 logger.debug(f"Pokemon {pokemon.nickname} was frozen.")

            message = f"{pokemon.nickname} {status_effect.name}了！" # TODO: Refine message (S133 refinement)
            events.append(StatusEffectAppliedEvent(pokemon=pokemon, status_effect=status_effect, message=message))
            logger.info(f"Status effect {status_effect.logic_key} applied to {pokemon.nickname}.")
        elif status_effect.effect_type == 'volatile':
            # TODO: Check if volatile status can stack or has duration (S125 refinement)
            # For now, just add it to the list
            pokemon.volatile_status_effects.append(status_effect)
            message = f"{pokemon.nickname} 陷入了 {status_effect.name} 状态！" # TODO: Refine status message
            events.append(StatusEffectAppliedEvent(pokemon=pokemon, status_effect=status_effect, message=message))
            logger.debug(f"Applied volatile status effect {status_effect.name} to {pokemon.nickname}")
        # TODO: Handle other effect types if necessary (e.g., field effects applied by skills) (S114 refinement)

        return events

    def remove_status_effect(self, pokemon: Pokemon, status_logic_key: str, is_volatile: bool = False) -> List[BattleEvent]:
        """
        Removes a status effect from a Pokemon.

        Args:
            pokemon: The Pokemon to remove the status effect from.
            status_logic_key: The logic key of the status effect to remove.
            is_volatile: True if removing a volatile status, False for major status.

        Returns:
            A list of BattleEvent objects generated by the removal attempt.
        """
        events: List[BattleEvent] = []
        removed = False

        if not is_volatile:
            # Remove major status
            if pokemon.status_effect and pokemon.status_effect.logic_key == status_logic_key:
                status_name = pokemon.status_effect.name
                pokemon.status_effect = None
                message = f"{pokemon.nickname} 的 {status_name} 状态解除了！" # TODO: Refine message
                events.append(StatusEffectRemovedEvent(pokemon=pokemon, status_logic_key=status_logic_key, is_volatile=False, message=message))
                logger.debug(f"Removed major status effect {status_logic_key} from {pokemon.nickname}")
                removed = True
        else:
            # Remove volatile status
            initial_count = len(pokemon.volatile_status_effects)
            pokemon.volatile_status_effects = [
                vse for vse in pokemon.volatile_status_effects if vse.logic_key != status_logic_key
            ]
            if len(pokemon.volatile_status_effects) < initial_count:
                # Assuming we remove all instances of a volatile status with the same logic key
                # If volatile statuses can stack and need individual removal, this logic needs adjustment.
                status_name = status_logic_key # We don't have the name easily here, might need to fetch from metadata
                status_obj = self._metadata_repo.get_status_effect_by_logic_key(status_logic_key)
                if status_obj:
                     status_name = status_obj.name
                message = f"{pokemon.nickname} 的 {status_name} 状态解除了！" # TODO: Refine message
                events.append(StatusEffectRemovedEvent(pokemon=pokemon, status_logic_key=status_logic_key, is_volatile=True, message=message))
                logger.debug(f"Removed volatile status effect {status_logic_key} from {pokemon.nickname}")
                removed = True

        # TODO: Add message if status was not present (S1 refinement)
        # if not removed:
        #      events.append(BattleMessageEvent(message=f"{pokemon.nickname} 没有 {status_logic_key} 状态。"))

        return events

    def process_end_of_turn_effects(self, pokemon: Pokemon) -> List[BattleEvent]:
        """
        Processes effects that occur at the end of the turn for a single Pokemon.

        Args:
            pokemon: The Pokemon whose end-of-turn effects are processed.

        Returns:
            A list of BattleEvent objects generated by the effects.
        """
        events: List[BattleEvent] = []

        # Process major status effect end-of-turn effects (S130 refinement)
        if pokemon.status_effect:
             if pokemon.status_effect.logic_key == 'poison':
                  # Deal 1/8 of max HP damage
                  damage = max(1, pokemon.max_hp // 8) # Deal at least 1 damage
                  pokemon.current_hp -= damage
                  events.append(DamageDealtEvent(attacker=None, defender=pokemon, skill=None, damage=damage, is_critical=False, effectiveness=1.0, message=f"{pokemon.nickname} 中毒了！")) # TODO: Refine message
                  # TODO: Check for faint after damage (S130 refinement)
             elif pokemon.status_effect.logic_key == 'burn':
                  # Deal 1/16 of max HP damage (usually, check rules)
                  damage = max(1, pokemon.max_hp // 16) # Deal at least 1 damage
                  pokemon.current_hp -= damage
                  events.append(DamageDealtEvent(attacker=None, defender=pokemon, skill=None, damage=damage, is_critical=False, effectiveness=1.0, message=f"{pokemon.nickname} 被灼伤了！")) # TODO: Refine message
                  # TODO: Check for faint after damage (S130 refinement)
             # TODO: Add logic for other major status effects like sleep (potential wake up) or freeze (potential thaw) (S130 refinement)

        # Process volatile status effect end-of-turn effects (S130 refinement)
        # This might involve decrementing turns, checking for recovery, etc.
        # Example: Confusion duration decrement
        # Note: Some volatile statuses are checked at the start of the turn (e.g., paralysis, confusion hit chance)
        # We'll handle those in BattleLogic before the action.
        # This section is for effects that *only* happen at the end of the turn.
        # TODO: Implement volatile status duration decrement and removal (S130 refinement)
        # Example:
        # new_volatile_status_effects = []
        # for vse in pokemon.volatile_status_effects:
        #      if vse.duration > 0: # Assuming duration is tracked
        #           vse.duration -= 1
        #           if vse.duration == 0:
        #                events.extend(self.remove_status_effect(pokemon, vse.logic_key, is_volatile=True))
        #           else:
        #                new_volatile_status_effects.append(vse)
        #      else: # Handle statuses without duration, if any
        #           new_volatile_status_effects.append(vse)
        # pokemon.volatile_status_effects = new_volatile_status_effects

        return events

    def process_start_of_turn_effects(self, pokemon: Pokemon, battle: 'Battle') -> Tuple[List[BattleEvent], bool]:
        """
        Processes effects that occur at the start of the turn for a single Pokemon,
        such as volatile status checks (paralysis, confusion). (S131)

        Args:
            pokemon: The Pokemon whose start-of-turn effects are processed.
            battle: The battle object.

        Returns:
            A list of BattleEvent objects generated by the effects.
            Returns events and a boolean indicating if the pokemon can act this turn.
        """
        events: List[BattleEvent] = []
        can_act = True

        # S131: Process major status effects that affect action
        if pokemon.status_effect:
            if pokemon.status_effect.logic_key == 'paralysis':
                # 25% chance to be unable to move
                if random.random() < 0.25: # TODO: Make paralysis chance configurable (S131 refinement)
                    events.append(BattleMessageEvent(message=f"{pokemon.nickname} 麻痹了，无法行动！")) # TODO: Refine message (S131 refinement)
                    can_act = False
                    logger.debug(f"{pokemon.nickname} is paralyzed and cannot act.")
                    return events, can_act # Return early if cannot act due to paralysis

            # TODO: Add checks for other major statuses that prevent action (e.g., sleep, freeze) (S131 refinement)
            elif pokemon.status_effect.logic_key == 'sleep':
                 pokemon.sleep_turns -= 1 # Decrement sleep turns (S131 refinement)
                 logger.debug(f"Pokemon {pokemon.nickname} has {pokemon.sleep_turns} turns of sleep remaining.")
                 if pokemon.sleep_turns <= 0:
                     # Wake up
                     events.extend(self.remove_status_effect(pokemon, 'sleep', is_volatile=False))
                     message = f"{pokemon.nickname} 醒来了！" # TODO: Refine message (S131 refinement)
                     events.append(BattleMessageEvent(message=message))
                     logger.debug(f"Pokemon {pokemon.nickname} woke up.")
                     # can_act remains True as they can act this turn after waking up
                 else:
                     # Still asleep
                     events.append(BattleMessageEvent(message=f"{pokemon.nickname} 睡着了！")) # TODO: Refine message (S131 refinement)
                     can_act = False
                     logger.debug(f"Pokemon {pokemon.nickname} is still asleep and cannot act.")
                     # No need to return early
            elif pokemon.status_effect.logic_key == 'freeze':
                 pokemon.freeze_turns += 1 # Increment freeze turns (S131 refinement)
                 # 20% chance to thaw each turn (usually)
                 # TODO: Make freeze thaw chance configurable (S131 refinement)
                 # TODO: Implement thaw chance modification by items (e.g., Heat Rock) (S131 refinement)
                 thaw_chance = 0.20
                 # Check for items that might affect thaw chance (e.g., Heat Rock doesn't affect thaw, but others might)
                 # if pokemon.held_item_id:
                 #      item = self._metadata_repo.get_item(pokemon.held_item_id)
                 #      if item and item.logic_key == 'heat_rock': # Example check
                 #           thaw_chance *= 1.5 # Example modification

                 if random.random() < thaw_chance:
                     # Thaw
                     events.extend(self.remove_status_effect(pokemon, 'freeze', is_volatile=False))
                     message = f"{pokemon.nickname} 解冻了！" # TODO: Refine message (S131 refinement)
                     events.append(BattleMessageEvent(message=message))
                     logger.debug(f"Pokemon {pokemon.nickname} thawed.")
                     # can_act remains True as they can act this turn after thawing
                 else:
                     # Still frozen
                     events.append(BattleMessageEvent(message=f"{pokemon.nickname} 冰冻着！")) # TODO: Refine message (S131 refinement)
                     can_act = False
                     logger.debug(f"Pokemon {pokemon.nickname} is still frozen and cannot act.")
                     # No need to return early


        # S131: Process volatile status effects that affect action (e.g., confusion)
        # Note: Some volatile statuses like flinch are checked *after* move selection but *before* execution.
        # This method is for checks *before* selecting/attempting a move.
        # Confusion check happens here. Flinch check happens in _execute_skill_action or similar.
        for vse in pokemon.volatile_status_effects:
            if vse.logic_key == 'confusion':
                # 50% chance to hit itself
                if random.random() < 0.5: # TODO: Make confusion hit chance configurable (S131 refinement)
                    events.append(BattleMessageEvent(message=f"{pokemon.nickname} 混乱了，攻击了自己！")) # TODO: Refine message (S131 refinement)
                    logger.debug(f"Pokemon {pokemon.nickname} is confused and hit itself.")

                    # TODO: Calculate and apply confusion damage (S131 refinement)
                    # Confusion damage is calculated as a typeless physical attack with a base power of 40
                    # It uses the attacker's Attack and Defense stats
                    # We need a dummy skill-like object or pass parameters directly to calculate_damage
                    # Assuming calculate_damage can handle a 'confusion' type or specific parameters
                    # For confusion, attacker is the same as defender
                    # Base power for confusion is typically 40
                    # It's a physical attack, typeless
                    confusion_base_power = 40 # TODO: Make confusion base power configurable (S131 refinement)
                    # We need to pass necessary info to calculate_damage, potentially including stats, level, etc.
                    # Assuming calculate_damage signature is something like:
                    # calculate_damage(attacker, defender, skill_power, skill_type, is_critical, field_state)
                    # For confusion: attacker=pokemon, defender=pokemon, skill_power=confusion_base_power, skill_type=None (typeless), is_critical=False, field_state=None (or relevant battle state)

                    # Create a dummy object or pass parameters representing confusion attack
                    # Let's assume calculate_damage takes attacker, defender, base_power, attack_type, is_critical, field_state
                    # We might need to pass battle state for field effects, but for confusion self-damage, it's usually simple.
                    # Let's refine the call based on the assumed calculate_damage signature
                    # Assuming calculate_damage(attacker: Pokemon, defender: Pokemon, base_power: int, attack_type: Optional[Attribute], is_critical: bool, field_state: Any) -> int:
                    # We need to get the Normal attribute for typeless damage calculation if the formula uses it, or handle None.
                    # Let's assume calculate_damage handles None type as typeless.
                    # We also need to pass a dummy skill or just the power and type.
                    # Let's assume calculate_damage takes attacker, defender, base_power, attack_category (physical/special), attack_type, is_critical, field_state
                    # Confusion is physical, typeless.
                    # We might need to pass the battle object or relevant state for abilities/items that affect damage.
                    # Let's simplify for now and assume calculate_damage only needs attacker, defender, base_power, attack_category, attack_type.
                    # We'll need to get the 'physical' category somehow. Maybe an enum or string.
                    # Let's assume 'physical' is a string for now.
                    # We also need to pass the battle object to calculate_damage for full context (abilities, items, field effects)
                    # Let's assume calculate_damage(battle: Battle, attacker: Pokemon, defender: Pokemon, base_power: int, attack_category: str, attack_type: Optional[Attribute], is_critical: bool) -> int:
                    # We need the battle object here. Let's add it to the method signature.
                    # This requires changing the BattleLogic call to pass the battle object.
                    # Let's adjust the plan:
                    # 1. Modify process_start_of_turn_effects signature to accept battle object.
                    # 2. Modify BattleLogic.process_turn to pass the battle object.
                    # 3. Call calculate_damage with appropriate parameters for confusion.
                    # 4. Apply the calculated damage.
                    # 5. Check for faint.

                    # Re-evaluating: Passing the whole battle object might be too much dependency for StatusEffectHandler.
                    # The core logic (damage calculation) should ideally be in formulas.py and take only necessary inputs.
                    # Let's assume calculate_damage takes attacker, defender, base_power, attack_category, attack_type, and potentially ability/item effects directly or indirectly.
                    # A simpler approach for confusion damage in StatusEffectHandler:
                    # Calculate a basic damage value here and then use the existing damage application mechanism (DamageDealtEvent).
                    # The DamageDealtEvent handler in BattleLogic should then apply the damage and check for faint.
                    # This keeps StatusEffectHandler focused on status effects and BattleLogic on orchestrating the turn.

                    # Let's revert to the original plan of calculating damage here and publishing DamageDealtEvent.
                    # We need a way to calculate confusion damage without a full skill object.
                    # Let's create a simplified confusion damage calculation within this method for now,
                    # or assume calculate_damage can take specific parameters for confusion.
                    # Given the TODO in BattleLogic about calculate_damage, it's likely intended to be a central function.
                    # Let's assume calculate_damage exists and can handle confusion with specific parameters.
                    # Let's assume calculate_damage(attacker: Pokemon, defender: Pokemon, confusion_power: int, is_critical: bool) -> int: # Simplified signature for confusion
                    # This simplified signature doesn't account for typeless, physical, stats, abilities, items, field.
                    # This is getting complex. Let's stick to the original TODO in BattleLogic and assume calculate_damage is there and handles the full logic.
                    # The TODO in BattleLogic was: damage = calculate_damage(attacker, target, skill, effectiveness, is_critical, battle.field_state)
                    # This signature is for skill damage. Confusion is not a skill.

                    # Let's reconsider the structure. StatusEffectHandler should probably *not* calculate damage directly.
                    # It should determine *if* confusion damage occurs and *how much* (base power, type, category),
                    # then publish an event that BattleLogic's event handler processes, including calling calculate_damage.
                    # This aligns better with the event-driven architecture and separation of concerns.

                    # New Plan:
                    # 1. In StatusEffectHandler.process_start_of_turn_effects, if confusion hits, publish a new event: ConfusionDamageEvent.
                    # 2. Create a new event class: ConfusionDamageEvent in backend/core/battle/events.py.
                    # 3. In BattleLogic, add an event handler for ConfusionDamageEvent.
                    # 4. This handler will call calculate_damage (which we still need to define/assume exists in formulas.py)
                    #    with the attacker as both attacker and defender, base power 40, physical, typeless.
                    # 5. The handler will then publish a DamageDealtEvent based on the calculated damage.
                    # 6. The existing DamageDealtEvent handler will apply the damage and check for faint.

                    # Let's implement Step 1 and 2 now.

                    # Publish ConfusionDamageEvent
                    events.append(ConfusionDamageEvent(pokemon=pokemon, base_power=confusion_base_power)) # Publish event for BattleLogic to handle damage calculation and application
                    logger.debug(f"Published ConfusionDamageEvent for {pokemon.nickname}.")

                else:
                    events.append(BattleMessageEvent(message=f"{pokemon.nickname} 混乱了，但没有攻击自己！")) # TODO: Refine message (S131 refinement)
                    logger.debug(f"Pokemon {pokemon.nickname} is confused but did not hit itself.")
                    # can_act remains True, they can attempt to use their chosen move

        # TODO: Add checks for other volatile statuses that prevent action (e.g., flinch - might be elsewhere) (S131 refinement)

        # TODO: After processing start-of-turn effects, check if the pokemon fainted (e.g., from confusion damage) (S107 refinement)
        # This check will now be handled by the DamageDealtEvent handler in BattleLogic, which is triggered by ConfusionDamageEvent.
        # So, this specific TODO here can be removed or marked as handled by event system.

        return events, can_act

    def apply_stat_stage_change(self, pokemon: Pokemon, stat_type: str, stages: int) -> List[BattleEvent]:
        """
        Applies a stat stage change to a Pokemon.

        Args:
            pokemon: The Pokemon whose stat stage is changing.
            stat_type: The type of stat changing (e.g., 'attack', 'defense').
            stages: The number of stages to change (positive for increase, negative for decrease).

        Returns:
            A list of BattleEvent objects generated by the change attempt.
        """
        events: List[BattleEvent] = []
        current_stage = pokemon.stat_stages.get(stat_type, 0)
        new_stage = max(-6, min(6, current_stage + stages)) # Stat stages are between -6 and +6

        if new_stage == current_stage:
            # No change occurred (e.g., already at +6 and tried to increase)
            message = f"{pokemon.nickname} 的 {stat_type} 没有变化！" # TODO: Refine message based on attempt vs actual change
            events.append(BattleMessageEvent(message=message))
            return events

        pokemon.stat_stages[stat_type] = new_stage

        message = f"{pokemon.nickname} 的 {stat_type} {'提高' if stages > 0 else '降低'}了！" # Basic message
        # TODO: Refine message based on number of stages (e.g., sharply rose/fell) (S119 refinement)

        events.append(StatStageChangeEvent(pokemon=pokemon, stat_type=stat_type, stages_changed=stages, new_stage=new_stage, message=message))

        return events

    # TODO: Add methods for removing status effects, processing end-of-turn effects, etc. (S130 refinement) 