from typing import Optional, Dict, Any, List, Tuple
from backend.models.player import Player
from backend.models.pokemon import Pokemon, PokemonSkill
from backend.models.battle import Battle
from backend.models.skill import Skill # Import Skill model
from backend.models.item import Item # Import Item model
from backend.data_access.repositories.player_repository import PlayerRepository
from backend.data_access.repositories.pokemon_repository import PokemonRepository
from backend.data_access.repositories.battle_repository import BattleRepository # Assuming BattleRepository exists or will be created
from backend.data_access.repositories.metadata_repository import MetadataRepository # Need MetadataRepository for skills and items
from backend.core.battle.battle_logic import BattleLogic # Import BattleLogic
from backend.core.services.item_service import ItemService # Import ItemService for item usage
from backend.utils.logger import get_logger
from backend.utils.exceptions import (
    BattleNotFoundException, InvalidBattleActionException,
    PokemonFaintedException, SkillNotFoundException,
    InvalidTargetException, NotEnoughPokemonException,
    BattleFinishedException, ItemNotFoundException # Import ItemNotFoundException
)
from backend.core.battle.events import BattleEvent # Import BattleEvent

logger = get_logger(__name__)

class BattleService:
    """Service for managing battle sessions and orchestrating battle logic."""

    def __init__(self):
        # TODO: Consider dependency injection for repositories and other services (S93 refinement)
        self.player_repo = PlayerRepository()
        self.pokemon_repo = PokemonRepository()
        self.battle_repo = BattleRepository()
        self.metadata_repo = MetadataRepository()
        self.item_service = ItemService() # Need ItemService for item usage in battle
        self.battle_logic = BattleLogic(metadata_repo=self.metadata_repo) # Instantiate BattleLogic


    async def start_wild_pokemon_battle(self, player_id: str, wild_pokemon_race_id: int, wild_pokemon_level: int) -> Tuple[List[str], Optional[str]]:
        """Starts a battle between a player and a wild pokemon."""
        logger.info(f"Attempting to start wild pokemon battle for player {player_id} against race {wild_pokemon_race_id} level {wild_pokemon_level}")
        messages = []
        try:
            player = await self.player_repo.get_player(player_id)
            if not player:
                raise PlayerNotFoundException(f"Player with ID {player_id} not found.")

            # Check if player is already in a battle
            if player.battle_id:
                 messages.append("你已经在战斗中！")
                 return messages, None # Player is already in a battle

            # Get player's party
            player_party = await self.pokemon_repo.get_player_pokemons(player_id)
            if not player_party:
                 messages.append("你没有宝可梦可以战斗！")
                 return messages, None # Player has no pokemon

            # Find the first available pokemon in the party
            active_pokemon = None
            for pokemon in player_party:
                 if not pokemon.is_fainted:
                      active_pokemon = pokemon
                      break

            if not active_pokemon:
                 messages.append("你的所有宝可梦都已濒死，无法开始战斗！")
                 return messages, None # All pokemon fainted

            # Create a wild pokemon instance
            # Need race data to create the instance
            wild_race_data = self.metadata_repo.get_race_by_id(wild_pokemon_race_id)
            if not wild_race_data:
                 logger.error(f"Wild pokemon race ID {wild_pokemon_race_id} not found in metadata.")
                 messages.append("无法找到该野生宝可梦的数据。")
                 return messages, None

            # Create the wild pokemon instance
            wild_pokemon = Pokemon(
                player_id=None, # Wild pokemon has no owner
                race_id=wild_pokemon_race_id,
                nickname=wild_race_data.name, # Use race name as nickname for wild pokemon
                level=wild_pokemon_level,
                # IVs and EVs are randomly generated by default in Pokemon model
            )

            # Load race data into the pokemon instance and calculate initial stats
            wild_pokemon.race = wild_race_data
            calculate_stats(wild_pokemon, wild_pokemon.race, self.metadata_repo) # Calculate initial stats
            wild_pokemon.current_hp = wild_pokemon.max_hp # Start with full HP

            # Save the wild pokemon instance to get an instance_id
            wild_pokemon_instance_id = await self.pokemon_repo.save_pokemon_instance(wild_pokemon)
            wild_pokemon.instance_id = wild_pokemon_instance_id # Set the instance_id on the object

            # Load race data for player's active pokemon as well
            if not active_pokemon.race:
                 active_pokemon.race = self.metadata_repo.get_race_by_id(active_pokemon.race_id)
                 if active_pokemon.race:
                      calculate_stats(active_pokemon, active_pokemon.race, self.metadata_repo)
                      # Initialize current HP if it's None after loading
                      if active_pokemon.current_hp is None and active_pokemon.max_hp is not None:
                           active_pokemon.current_hp = active_pokemon.max_hp
                 else:
                      logger.error(f"Could not load race data for player pokemon {active_pokemon.nickname} (ID: {active_pokemon.race_id}).")
                      messages.append(f"无法加载 {active_pokemon.nickname} 的种族数据。")
                      await self.pokemon_repo.delete_pokemon_instance(wild_pokemon_instance_id)
                      return messages, None

            # Create a new battle instance
            battle = Battle(
                player_id=player_id,
                wild_pokemon_instance_id=wild_pokemon.instance_id,
                player_active_pokemon_instance_id=active_pokemon.instance_id,
                turn_number=1,
                is_finished=False,
                outcome=None,
                # Initialize other battle state fields as needed
                player_party_instance_ids=[p.instance_id for p in player_party], # Store party instance IDs
                wild_pokemon_original_race_id=wild_pokemon_race_id, # Store original race ID for EXP/Catch rate
                wild_pokemon_original_level=wild_pokemon_level, # Store original level for EXP
            )

            # Save the battle instance
            battle_id = await self.battle_repo.save_battle(battle)
            battle.battle_id = battle_id # Set the battle_id on the object

            # Link the battle to the player
            player.battle_id = battle_id
            await self.player_repo.save_player(player)

            messages.append(f"你遇到了野生的 {wild_pokemon.nickname} (Lv.{wild_pokemon.level})！")
            messages.append(f"你派出了 {active_pokemon.nickname}！")

            # TODO: Publish BattleStartEvent (S31 refinement)
            # self.battle_logic.publish(battle, BattleStartEvent(battle=battle, message=messages[-2])) # Example

            return messages, None # Battle started, not finished yet

        except PlayerNotFoundException as e:
            logger.warning(f"Failed to start battle: {e}")
            messages.append(str(e))
            return messages, None
        except Exception as e:
            logger.error(f"An unexpected error occurred while starting battle for player {player_id}: {e}", exc_info=True)
            messages.append("开始战斗时发生未知错误。")
            # Attempt to clean up created pokemon/battle if they exist
            # TODO: Implement more robust cleanup or transaction management (S32 refinement)
            return messages, None

    async def get_player_active_battle(self, player_id: str) -> Optional[Battle]:
        """Gets the active battle for a player."""
        player = await self.player_repo.get_player(player_id)
        if player and player.battle_id:
            return await self.battle_repo.get_battle(player.battle_id)
        return None

    async def process_player_action(self, player_id: str, action: Dict[str, Any]) -> Tuple[List[str], Optional[str]]:
        """Processes a player's action during a battle turn."""
        messages = []
        outcome = None # 'win', 'lose', 'ran', 'caught', 'draw', 'error'
        battle_ended = False
        events: List[BattleEvent] = [] # Collect events

        try:
            player = await self.player_repo.get_player(player_id)
            if not player or not player.battle_id:
                messages.append("你当前不在战斗中。")
                return messages, None

            battle = await self.battle_repo.get_battle(player.battle_id)
            if not battle:
                # This should not happen if player.battle_id is set, but handle defensively
                logger.error(f"Battle ID {player.battle_id} not found for player {player_id}.")
                player.battle_id = None # Clear invalid battle_id
                await self.player_repo.save_player(player)
                messages.append("战斗状态异常，已退出。")
                return messages, None


            if battle.is_finished:
                 messages.append("战斗已经结束了。")
                 # Clear player's battle_id if battle is finished but still linked
                 player.battle_id = None
                 await self.player_repo.save_player(player)
                 return messages, battle.outcome # Return the actual outcome if battle was finished


            # Get active pokemon instances
            player_pokemon = await self.pokemon_repo.get_pokemon_instance_by_id(battle.player_active_pokemon_instance_id)
            wild_pokemon = await self.pokemon_repo.get_pokemon_instance_by_id(battle.wild_pokemon_instance_id)

            if not player_pokemon or not wild_pokemon:
                 logger.error(f"Active pokemon not found for battle {battle.battle_id}. Player active: {battle.player_active_pokemon_instance_id}, Wild: {battle.wild_pokemon_instance_id}")
                 messages.append("战斗中的宝可梦数据异常，战斗已结束。")
                 await self.end_battle(battle.battle_id, 'error')
                 return messages, 'error'

            # Ensure race data is loaded for active pokemon
            if not player_pokemon.race:
                 player_pokemon.race = self.metadata_repo.get_race_by_id(player_pokemon.race_id)
                 if player_pokemon.race:
                      calculate_stats(player_pokemon, player_pokemon.race, self.metadata_repo)
                      if player_pokemon.current_hp is None and player_pokemon.max_hp is not None:
                           player_pokemon.current_hp = player_pokemon.max_hp
                 else:
                      logger.error(f"Could not load race data for player pokemon {player_pokemon.nickname} (ID: {player_pokemon.race_id}).")
                      messages.append(f"无法加载 {player_pokemon.nickname} 的种族数据。")
                      await self.end_battle(battle.battle_id, 'error')
                      return messages, 'error'


            if not wild_pokemon.race:
                 wild_pokemon.race = self.metadata_repo.get_race_by_id(wild_pokemon.race_id)
                 if wild_pokemon.race:
                      calculate_stats(wild_pokemon, wild_pokemon.race, self.metadata_repo)
                      if wild_pokemon.current_hp is None and wild_pokemon.max_hp is not None:
                           wild_pokemon.current_hp = wild_pokemon.max_hp
                 else:
                      logger.error(f"Could not load race data for wild pokemon {wild_pokemon.nickname} (ID: {wild_pokemon.race_id}).")
                      messages.append(f"无法加载野生 {wild_pokemon.nickname} 的种族数据。")
                      await self.end_battle(battle.battle_id, 'error')
                      return messages, 'error'


            # Validate player action
            action_type = action.get('type')
            if action_type not in ['skill', 'switch', 'item', 'run', 'catch']:
                 raise InvalidBattleActionException(f"Invalid action type: {action_type}")

            # Check if player's active pokemon is fainted, only switch/item/run allowed
            if player_pokemon.is_fainted and action_type not in ['switch', 'item', 'run']:
                 raise PokemonFaintedException(f"{player_pokemon.nickname} 已经濒死，无法执行 {action_type} 行动。请切换宝可梦。")

            # Process the player action based on type
            if action_type == 'skill':
                skill_id = action.get('skill_id')
                target_instance_id = action.get('target_instance_id') # Target of the skill
                # Call the specific skill action processing method
                action_events, battle_ended, outcome = await self._process_skill_action(battle, player_pokemon, wild_pokemon, action)
                events.extend(action_events) # Collect events from skill action
            elif action_type == 'switch':
                target_pokemon_instance_id = action.get('target_pokemon_instance_id')
                # Call the specific switch action processing method
                action_events, battle_ended, outcome = await self._process_switch_action(battle, player_pokemon, wild_pokemon, action)
                events.extend(action_events) # Collect events from switch action
            elif action_type == 'item':
                item_id = action.get('item_id')
                target_instance_id = action.get('target_instance_id')
                # TODO: Implement _process_item_action (S56 refinement)
                # action_events, battle_ended, outcome = await self._process_item_action(battle, player_pokemon, wild_pokemon, action)
                # events.extend(action_events)
                messages.append("使用物品功能待实现。") # Placeholder
                battle_ended, outcome = False, None # Battle continues
                events.append(BattleMessageEvent(message="使用物品功能待实现。")) # Placeholder event
            elif action_type == 'run':
                # TODO: Implement _process_run_action (S57 refinement)
                # action_events, battle_ended, outcome = await self._process_run_action(battle, player_pokemon, wild_pokemon, action)
                # events.extend(action_events)
                messages.append("逃跑功能待实现。") # Placeholder
                battle_ended, outcome = False, None # Battle continues
                events.append(BattleMessageEvent(message="逃跑功能待实现。")) # Placeholder event
            elif action_type == 'catch':
                # TODO: Implement _process_catch_action (S58 refinement)
                # action_events, battle_ended, outcome = await self._process_catch_action(battle, player_pokemon, wild_pokemon, action)
                # events.extend(action_events)
                messages.append("捕捉功能待实现。") # Placeholder
                battle_ended, outcome = False, None # Battle continues
                events.append(BattleMessageEvent(message="捕捉功能待实现。")) # Placeholder event


            # TODO: Process opponent action (S38 refinement)
            # This will involve calling BattleLogic's _execute_action for the opponent
            # Need to handle the return value (battle_ended, outcome) and messages
            # For now, just a placeholder message
            # messages.append(f"野生的 {wild_pokemon.nickname} 使用了 {self.metadata_repo.get_skill(opponent_action['skill_id']).name}！")
            # TODO: Call BattleLogic to execute opponent action (S39 refinement)
            # battle_ended, outcome = await self.battle_logic._execute_action(battle, wild_pokemon, player_pokemon, opponent_action, is_player_action=False)
            # Need to integrate event handling here to collect messages from BattleLogic (S40 refinement)
            # For now, simulate a turn end and check for battle end conditions
            # TODO: Implement full turn processing including speed order, status effects, etc. (S41 refinement)
            # This will likely involve a new method in BattleLogic like process_turn(battle, player_action, opponent_action)

            # For now, let's simulate a simple turn where player acts, then opponent acts (if not fainted)
            # This is a temporary simplification until full turn logic is implemented.

            # Check if wild pokemon fainted after player's action
            if wild_pokemon.is_fainted:
                 # This should be handled by FaintEvent processing, but adding a check here for now
                 if not battle_ended: # Only set outcome if not already set by action
                    messages.append(f"野生的 {wild_pokemon.nickname} 失去了战斗能力！")
                    battle_ended, outcome = True, 'win' # Player wins
                    events.append(FaintEvent(pokemon=wild_pokemon, message=messages[-1])) # Add FaintEvent

            if not battle_ended: # If battle is not over after player action
                # Opponent acts (Simplified for now)
                # TODO: Implement opponent action selection and execution via BattleLogic (S42 refinement)
                # For now, just a placeholder
                # messages.append(f"野生的 {wild_pokemon.nickname} 的回合...")
                # Simulate opponent action and events
                opponent_action_events: List[BattleEvent] = []
                # TODO: Replace with actual opponent action logic and BattleLogic call (S42 refinement)
                # For now, simulate opponent using a random skill if not fainted
                if not wild_pokemon.is_fainted:
                    wild_pokemon_skills = await self.pokemon_repo.get_pokemon_skills(wild_pokemon.instance_id)
                    if wild_pokemon_skills:
                        # Select a random skill (simplified)
                        random_skill_instance = random.choice(wild_pokemon_skills)
                        random_skill = self.metadata_repo.get_skill(random_skill_instance.skill_id)
                        if random_skill:
                             # Simulate opponent using the skill on the player's active pokemon
                             # TODO: Replace with actual BattleLogic.execute_skill call (S42 refinement)
                             simulated_opponent_events = self.battle_logic.execute_skill(battle, wild_pokemon, player_pokemon, random_skill) # Assuming execute_skill is synchronous for now
                             opponent_action_events.extend(simulated_opponent_events)
                             # Update pokemon states based on simulated events (This will be handled by event handlers later)
                             for event in simulated_opponent_events:
                                 if isinstance(event, DamageDealtEvent):
                                     event.defender.current_hp = max(0, event.defender.current_hp - event.damage)
                                 # TODO: Handle other event types to update pokemon state (S100 refinement)

                events.extend(opponent_action_events) # Collect events from opponent action

                # Check if player pokemon fainted after opponent's action
                if player_pokemon.is_fainted:
                     # This should be handled by FaintEvent processing, but adding a check here for now
                     if not battle_ended: # Only set outcome if not already set
                        messages.append(f"{player_pokemon.nickname} 失去了战斗能力！")
                        events.append(FaintEvent(pokemon=player_pokemon, message=messages[-1])) # Add FaintEvent
                        # Check if player has other usable pokemon
                        player_party = await self.pokemon_repo.get_player_pokemons(player_id)
                        has_usable_pokemon = any(p for p in player_party if not p.is_fainted and p.instance_id != player_pokemon.instance_id)
                        if has_usable_pokemon:
                             messages.append("请选择下一只宝可梦！")
                             # TODO: Transition to a "waiting for switch" state (S43 refinement)
                             battle_ended, outcome = False, None # Battle continues, waiting for switch
                             events.append(BattleMessageEvent(message="请选择下一只宝可梦！")) # Add message event
                        else:
                             messages.append("你的所有宝可梦都已濒死！")
                             battle_ended, outcome = True, 'lose' # Player loses
                             events.append(BattleMessageEvent(message="你的所有宝可梦都已濒死！")) # Add message event


            # S53: Collect messages from BattleLogic events
            # Process the collected events and generate detailed messages
            generated_messages = self._format_battle_events_to_messages(events)
            messages.extend(generated_messages) # Add generated messages to the list

            # TODO: Save updated pokemon states (HP, status, stat stages, PP) to database (S101 refinement)
            # This needs to happen after all actions and effects for the turn are processed.
            # Need to update Pokemon model and PokemonRepository to handle these updates.
            # For now, changes are only in memory.
            await self.pokemon_repo.save_pokemon_instance(player_pokemon) # Save player pokemon state
            await self.pokemon_repo.save_pokemon_instance(wild_pokemon) # Save wild pokemon state
            # TODO: Save updated PokemonSkill PP (S96 refinement) - Needs PokemonSkill update method in repo

            # Increment turn number if battle is not ended
            if not battle_ended:
                 battle.turn_number += 1
                 # TODO: Apply turn-end effects (status damage, terrain/weather effects) (S102 refinement)
                 # This should also generate events.

            # Save the updated battle state
            battle.is_finished = battle_ended
            battle.outcome = outcome
            await self.battle_repo.save_battle(battle)

            # If battle ended, clear player's battle_id
            if battle_ended:
                 player.battle_id = None
                 await self.player_repo.save_player(player)
                 # TODO: Handle post-battle logic (EXP gain, item drops, etc.) (S103 refinement)

            # Clear messages in the battle state for the next action/turn
            # battle.state.current_turn_messages = [] # Assuming battle state object exists

            return messages, outcome # Return collected messages and final outcome

        except (InvalidBattleActionException, PokemonFaintedException, InvalidTargetException, SkillNotFoundException) as e:
            messages.append(str(e))
            # If an error occurs, the battle state is not changed (except potentially clearing battle_id on critical errors)
            # The battle continues, and the player can try another action.
            return messages, None # Battle did not end due to invalid action

        except Exception as e:
            logger.error(f"An unexpected error occurred while processing battle action for player {player_id}: {e}", exc_info=True)
            messages.append("处理战斗行动时发生未知错误。")
            # On unexpected errors, end the battle with an error outcome
            if battle and battle.battle_id:
                 await self.end_battle(battle.battle_id, 'error')
            return messages, 'error'

    async def _process_skill_action(self, battle: Battle, player_pokemon: Pokemon, wild_pokemon: Pokemon, action: Dict[str, Any]) -> Tuple[List[BattleEvent], bool, Optional[str]]:
        """Handles the 'skill' action."""
        events: List[BattleEvent] = []
        battle_ended = False
        outcome = None

        skill_id = action.get('skill_id')
        target_instance_id = action.get('target_instance_id')

        if skill_id is None or target_instance_id is None:
             raise InvalidBattleActionException("Skill action requires 'skill_id' and 'target_instance_id'.")

        # Get the skill instance from the player's pokemon
        player_pokemon_skills = await self.pokemon_repo.get_pokemon_skills(player_pokemon.instance_id)
        pokemon_skill = next((ps for ps in player_pokemon_skills if ps.skill_id == skill_id), None)

        if not pokemon_skill:
             raise SkillNotFoundException(f"{player_pokemon.nickname} 没有学会 ID 为 {skill_id} 的技能。")

        # Get the skill metadata
        skill = self.metadata_repo.get_skill(skill_id)
        if not skill:
             # This should not happen if pokemon_skill exists, but handle defensively
             logger.error(f"Skill metadata not found for skill ID: {skill_id}")
             raise SkillNotFoundException(f"未找到技能 ID {skill_id} 的元数据。")

        # Check if skill has enough PP
        if pokemon_skill.current_pp <= 0:
             # messages.append(f"{player_pokemon.nickname} 的 {skill.name} 没有PP了！")
             # TODO: What happens when a skill has no PP? Struggle? Skip turn? (S95 refinement)
             # For now, we'll just return the message and the turn effectively ends for this pokemon.
             # The battle state is not changed, and the opponent still gets a turn (handled in process_player_action).
             events.append(BattleMessageEvent(message=f"{player_pokemon.nickname} 的 {skill.name} 没有PP了！"))
             return events, False, None

        # Determine the actual target pokemon object
        target_pokemon = None
        # TODO: Handle skills that target self, allies, or multiple targets based on skill.target_type (S48 refinement)
        # This logic needs to be more robust to handle different target types defined in the skills metadata.
        # For now, assuming single target skills against the opponent in a wild battle.
        if target_instance_id == wild_pokemon.instance_id:
             target_pokemon = wild_pokemon
        elif target_instance_id == player_pokemon.instance_id and skill.target_type == 'self':
             target_pokemon = player_pokemon
        # Add checks for other target types as needed

        if not target_pokemon:
             # If target_instance_id was provided but doesn't match expected targets
             raise InvalidTargetException(f"技能 {skill.name} 的目标无效。")

        # Consume 1 PP from the skill
        pokemon_skill.current_pp -= 1
        # TODO: Save the updated pokemon_skill PP to the database (S96 refinement)
        # This requires updating the Pokemon model and PokemonRepository to handle PokemonSkill updates.
        # For now, the change is only in memory.
        # await self.pokemon_repo.update_pokemon_skill_pp(pokemon_skill.pokemon_skill_id, pokemon_skill.current_pp) # Need this method

        events.append(BattleMessageEvent(message=f"{player_pokemon.nickname} 使用了 {skill.name}！"))

        # S49: Call BattleLogic to execute the skill action
        # The BattleLogic will handle damage calculation, status effects, etc.
        # It should return whether the battle ended and the outcome, and publish events for messages.
        # TODO: Implement BattleLogic.execute_skill method (S97 refinement)
        # This method should take the battle state, attacker, defender, skill, etc.
        # It should modify the pokemon states in place and return a list of events.
        # For now, we'll simulate calling it and getting some events.

        # Simulate BattleLogic execution and event generation
        # TODO: Replace with actual call to self.battle_logic.execute_skill (S97 refinement)
        simulated_events: List[BattleEvent] = []
        # Example: Simulate a damage event
        # simulated_damage = 50 # Placeholder
        # wild_pokemon.current_hp = max(0, wild_pokemon.current_hp - simulated_damage)
        # simulated_events.append(DamageDealtEvent(attacker=player_pokemon, defender=wild_pokemon, skill=skill, damage=simulated_damage, message=f"对 {wild_pokemon.nickname} 造成了 {simulated_damage} 点伤害！"))
        # Example: Simulate a status effect event
        # if random.random() < 0.1: # 10% chance to poison (placeholder)
        #      poison_status = self.metadata_repo.get_status_effect_by_logic_key('poison') # Need method to get by logic key
        #      if poison_status:
        #           # TODO: Apply status effect via BattleLogic (S98 refinement)
        #           # simulated_events.append(StatusEffectAppliedEvent(pokemon=wild_pokemon, status_effect=poison_status, message=f"{wild_pokemon.nickname} 中毒了！"))
        #           pass # Placeholder

        # Call BattleLogic to execute the skill and get events
        skill_execution_events = self.battle_logic.execute_skill(battle, player_pokemon, target_pokemon, skill) # Assuming execute_skill is synchronous for now
        events.extend(skill_execution_events)

        # TODO: Check for battle end conditions after skill execution (fainting, etc.) (S104 refinement)
        # This will be handled by processing the events, particularly FaintEvent.
        # For now, a simple check:
        if wild_pokemon.is_fainted:
             battle_ended = True
             outcome = 'win'
        elif player_pokemon.is_fainted:
             # Check if player has usable pokemon
             player_party = await self.pokemon_repo.get_player_pokemons(battle.player_id)
             has_usable_pokemon = any(p for p in player_party if not p.is_fainted and p.instance_id != player_pokemon.instance_id)
             if not has_usable_pokemon:
                  battle_ended = True
                  outcome = 'lose'
             # If player has usable pokemon, battle continues, waiting for switch (handled in process_player_action)


        return events, battle_ended, outcome


    async def _process_switch_action(self, battle: Battle, player_pokemon: Pokemon, wild_pokemon: Pokemon, action: Dict[str, Any]) -> Tuple[List[BattleEvent], bool, Optional[str]]:
        """Handles the 'switch' action."""
        events: List[BattleEvent] = []
        battle_ended = False
        outcome = None

        target_pokemon_instance_id = action.get('target_pokemon_instance_id')

        if target_pokemon_instance_id is None:
             raise InvalidBattleActionException("Switch action requires 'target_pokemon_instance_id'.")

        if target_pokemon_instance_id == player_pokemon.instance_id:
             raise InvalidBattleActionException("你已经派出了这只宝可梦。")

        # Get the target pokemon from the player's party
        player_party = await self.pokemon_repo.get_player_pokemons(battle.player_id)
        target_pokemon = next((p for p in player_party if p.instance_id == target_pokemon_instance_id), None)

        if not target_pokemon:
             raise PokemonNotFoundException(f"队伍中没有找到 ID 为 {target_pokemon_instance_id} 的宝可梦。")

        if target_pokemon.is_fainted:
             raise PokemonFaintedException(f"{target_pokemon.nickname} 已经濒死，无法替换上场。")

        # TODO: Check for trapping abilities/effects that prevent switching (S54 refinement)

        # Perform the switch
        old_active_pokemon_nickname = player_pokemon.nickname
        battle.player_active_pokemon_instance_id = target_pokemon_instance_id
        # TODO: Reset stat stages, volatile status effects on switch out (S55 refinement)
        # This logic should probably be in BattleLogic or a dedicated PokemonBattleState class

        events.append(SwitchOutEvent(pokemon=player_pokemon, message=f"你收回了 {old_active_pokemon_nickname}！"))
        events.append(SwitchInEvent(pokemon=target_pokemon, message=f"你派出了 {target_pokemon.nickname}！"))

        # TODO: Trigger switch-in abilities/effects (S105 refinement)
        # This should also generate events.

        return events, battle_ended, outcome

    # TODO: Implement _process_item_action (S56 refinement)
    # TODO: Implement _process_run_action (S57 refinement)
    # TODO: Implement _process_catch_action (S58 refinement)

    def _format_battle_events_to_messages(self, events: List[BattleEvent]) -> List[str]:
        """
        Formats a list of BattleEvent objects into a list of user-facing message strings.
        This method determines the level of detail based on the event type and its details.
        """
        messages: List[str] = []
        for event in events:
            # Use the message provided in the event if available
            if hasattr(event, 'message') and event.message:
                messages.append(event.message)
            else:
                # Fallback or more detailed formatting based on event type
                if isinstance(event, DamageDealtEvent):
                    msg = f"{event.attacker.nickname} 对 {event.defender.nickname} 造成了 {event.damage} 点伤害！"
                    if event.is_critical:
                        msg += " 这是击中要害！"
                    if event.is_effective:
                        msg += " 效果绝佳！"
                    if event.is_not_effective:
                        msg += " 效果不理想..."
                    if event.is_immune:
                        msg = f"{event.defender.nickname} 对 {event.skill.name} 没有反应！" # Immune overrides other messages
                    messages.append(msg)
                elif isinstance(event, StatusEffectAppliedEvent):
                    messages.append(f"{event.pokemon.nickname} {event.status_effect.name}了！")
                elif isinstance(event, StatusEffectRemovedEvent):
                     messages.append(f"{event.pokemon.nickname} 的 {event.status_effect.name} 消失了！")
                elif isinstance(event, StatStageChangeEvent):
                    change_word = "提升" if event.stages_changed > 0 else "下降"
                    messages.append(f"{event.pokemon.nickname} 的 {event.stat_type} {change_word}了 {abs(event.stages_changed)} 级！")
                elif isinstance(event, FaintEvent):
                    # Message is usually provided in the event, but fallback here
                    messages.append(f"{event.pokemon.nickname} 失去了战斗能力！")
                elif isinstance(event, SwitchOutEvent):
                     # Message is usually provided
                     messages.append(event.message)
                elif isinstance(event, SwitchInEvent):
                     # Message is usually provided
                     messages.append(event.message)
                elif isinstance(event, HealEvent):
                     messages.append(f"{event.pokemon.nickname} 恢复了 {event.amount} 点HP！")
                elif isinstance(event, AbilityTriggerEvent):
                     messages.append(f"{event.pokemon.nickname} 的特性【{event.ability.name}】发动了！")
                     if event.message: # Include specific ability message if provided
                          messages.append(event.message)
                elif isinstance(event, ItemTriggerEvent):
                     messages.append(f"{event.pokemon.nickname} 使用了 {event.item.name}！")
                     if event.message: # Include specific item message if provided
                          messages.append(event.message)
                elif isinstance(event, MoveMissedEvent):
                     messages.append(f"{event.pokemon.nickname} 的攻击没有命中！")
                elif isinstance(event, BattleMessageEvent):
                     # Generic message event, just append the message
                     messages.append(event.message)
                # TODO: Add formatting for other event types as they are implemented (S106 refinement)
                # Add more elif blocks here for other specific event types

        return messages


    async def end_battle(self, battle_id: int, outcome: str) -> None:
        """Ends a battle and updates the battle state."""
        try:
            battle = await self.battle_repo.get_battle(battle_id)
            if battle:
                battle.is_finished = True
                battle.outcome = outcome
                await self.battle_repo.save_battle(battle)
                # TODO: Clear player's battle_id (S107 refinement) - This is done in process_player_action now
                # TODO: Handle post-battle cleanup (remove wild pokemon instance if caught/fainted) (S108 refinement)
                if outcome in ['win', 'caught', 'ran', 'error']:
                     # For wild battles, the wild pokemon instance can be removed or marked
                     wild_pokemon = await self.pokemon_repo.get_pokemon_instance_by_id(battle.wild_pokemon_instance_id)
                     if wild_pokemon:
                          if outcome == 'caught':
                               # TODO: Update pokemon instance to link to player (S109 refinement)
                               pass # Implementation needed
                          else:
                               # Remove wild pokemon instance if not caught
                               await self.pokemon_repo.delete_pokemon_instance(battle.wild_pokemon_instance_id)

                logger.info(f"Battle {battle_id} ended with outcome: {outcome}")
            else:
                logger.warning(f"Attempted to end battle {battle_id} but it was not found.")
        except Exception as e:
            logger.error(f"An error occurred while ending battle {battle_id}: {e}", exc_info=True)